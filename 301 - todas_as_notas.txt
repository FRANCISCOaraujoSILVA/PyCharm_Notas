
——————————————————————————————————————————————————————————————
INTRODUÇÃO A LINGUAGEM PYTHON
1 - PEP8
2 - Dir e Help
3 - Recebendo dados do usuário
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
VARIÁVEIS E TIPOS DE DADOS EM PYTHON
4 - O tipo numérico
5 - O tipo float
6 - O tipo booleano
7 - O tipo string
8 - Escopo de variáveis
8a - O tipo None
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
ESTRUTURAS LÓGICAS E CONDICIONAIS EM PYTHON
9 - IF, ELSE, ELIF
10 - AND, OR, NOT, IS
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
ESTRUTURAS DE REPETIÇÃO EM PYTHON
11 - Loop for
12 - Entendendo e explorando ranges
13 - Loop while
14 - Saindo de loops com break
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
COLEÇÕES PYTHON
15 -  Listas
16 - Tuplas
17 - Dicionários
18 - Mapas
19 - Conjuntos
20 - Módulo Collections - Counter
21 - Módulo Collections - Default Dict
22 - Módulo Collections - Ordered Dict
23 - Módulo Collecitons - Named Tuple
24 - Módulo Collections - Deque
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
FUNÇÕES EM PYTHON
25 - Definindo funções
26 - Funções com retorno
27 - Funções com parâmetro
28 - Funções com parâmetro padrão
29 - Documentando funções com docstrings
30 - Entendendo o *args
31 - Entendendo o **kwargs
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
COMPREHENSIONS EM PYTHON
32 - List comprehension (parte 1)
33 - List comprehension (parte 2)
34 - Listas aninhadas
35 - Dictionary comprehension
36 - Set comprehension
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
EXPRESSÕES LAMBDAS E FUNÇÕES INTEGRADAS
37 - Utilizando lambdas
38 - Map
39 - Filter
40 - Reduce
41 - Any e all
42 - Generators
43 - Sorted
44 - Min e max
45 - Reversed
46 - LEN, ABS, SUM, ROUND
47 - Zip
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
DEBUGANDO E TRATANDO ERROS
48 - Levantando os próprios erros com raise
49 - O bloco Try/Except
50 - TRY, EXCEPT, ELSE, FINALLY
51 - Debugando o código com PDB
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
TRABALHANDO COM MÓDULOS E PACOTES EM PYTHON
52 - O módulo random
53 - Trabalhando com módulos Built-in
54 - Módulos customizados
55 - Instalando e utilizando módulos externos
56 - Pacotes
57 - Dunder Main e Dunder Name
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
LEITURA E ESCRITA EM ARQUIVOS
59 - Leitura de arquivos
60 - Seek e cursors
61 - O bloco with
62 - Escrevendo em arquivos
63 - Modos de arquivos
64 - StringI
65 - Sistema de arquivos - Navegação
66
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
ITERADORES E GERADORES PYTHON
67 - Entendendo iterators e iteráveis
68 - Criando sua própria versão de loop
69 - Escrevendo um iterator customizado
70 - Geradores
71 - Teste de memória com generators
72 - Teste de velocidade com expressões geradoras
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
DECORADORES EM PYTHON
73 - Funções de maior grandeza
74 - O que são decoradores
75 - Decoradores com diferentes assinaturas
76 - Preservando metadata com wraps
77 - Forçando tipos de dados com um decorador
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
ORIENTAÇÃO A OBJETOS COM PYTHON
78 - O que é orientação a objetos
79 - Classes
80 - Atributos
81 - Métodos
82 - Objetos
83 - Abstração e encapsulamento
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————
HERANÇA E POLIMORFISMO
84 - Herança
85 - Propriedades
86 - O método super()
87 - Herança múltipla
88 - MRO - Method Resolution Ordr --> esse arquivo é o MRO
89 - Polimorfismo
90 - Métodos mágicos
——————————————————————————————————————————————————————————————
..............................................................
——————————————————————————————————————————————————————————————

------------------------------------------------------------------------------------------------------------------

"""
                                    PEP8 - PROPOSTAS DE MELHORIAS PARA A LINGUAGEM PYTHON


Faça no terminal:
    - python
    - import this (veja o poema do programador)

- A ideia da pep8 é que possamos escrever códigos de forma pythônica, ou seja, visualmente bonitas

Dicas:
 - Utilizar Camel Case para nome de classes. Ou seja, NomeSobrenome: Observe as letras maiúsculas
 - Perceba que duas linhas em branco são necessárias para evitar a cobrinha
 - Para tirar erros de palavras, modifique em: file,settings,slelling,desativar typo
 - Utilizar nome minúsculo, separados por underline para funções ou variáveis


Veja abaixo como nomeamos classes e funções de forma pythônica.

class Calculadora:
    pass


class CalculadoraCientífica:
    pass


def soma():
    pass


def soma_dois():
    pass


Notas:
    - Use "#" para escrever comentários apenas de uma linha: # comentário
    - Observe o espaço entre "#" e "comentário". Ele é necessário
    - Use aspas triplas para comentários maiores que uma linha. Segue como exemplo este local onde estou colocando as
informações
    - Há uma linha à direita na vertical, para evitar cobrinhas não ultrapasse essa linha
    - Se o comentário for logo após um dado (na mesma linha), uma classe, uma função etc... é necessário deixar dois
    espaços entre esse dado e a cerquilha "#"
"""

numero = 4
numero_impar = 5

"""
    - Utilize 4 espaços para identação! se a regra não for seguida, não conseguiremos programar
    - Os dois pontos no fim da classe, função... indica que um novo bloco vai começar, por isso precisamos de 4 espaços
    - Não é recomendado usar o TAB do teclado para dar os espaços, muito embora ele esteja (em algumas máquinas)
    programado com 4 espaços da tecla space
    - Essa linguagem de programação é completamente dependente de indentação, por isso, tenha muito cuidado e fique
     atento
"""

if 'a' in 'banana':
    print('tem')

"""
    - Precisamos de duas linhas de espaço entre funções e definições de classes
    - Métodos dentro de uma classe devem ser separados com uma única linha em branco

Imports devem "sempre" ser feitos em linhas separadas.

Import errado
    - import sys. os

Import certo
    - import sys
    - import os

Podemos importar partes de uma biblioteca, e não há problema em fazer isso. Ideal para no máximo 3 módulos.

from types import StringType, ListType

Para mais de 3, fazemos assim:
from types import (
    StringTupe,
    ListType,
    SetType,
    OutroType
)

imports devem ser colocadas no topo do arquivo, logo depois de qualquer comentário ou docstring e antes de constantes 
ou variáveis globais.
"""

# Espaços em expressões e instruções

"""
Observe os espaços desnecessários (erro de indentação)

Não faça: 
    funcao( algo[ 1 ],{outro: 2})

Faça:
funcao(algo[1],{outro:2})

Não faça:
algo (1)

Faça:
algo(1)

Não faça:
dict ['chave'] = list [indice]

Faça:
dict['chave'] = list[indice]

Não faça (observe a falta de espaço):
x=1
y=3

Faça:
x = 1
y = 3

Notas:
- Podemos fazer comentários com três aspas simples também ('''texto'''). Mas é preferível usar três aspas duplas!
- Sempre termine uma instrução com uma NOVA linha
"""

------------------------------------------------------------------------------------------------------------------

"""
                            DIR E HELP - UTILITÁRIOS PARA AUXILIAR NA PROGRAMAÇÃO


dir: apresenta todos os atributos e funções/métodos disponíveis para determinado tipo de dado ou variável.

dir(tipo de dado ou variável)
    lower
    upper
    title

help: apresenta a documentação/como utilizar os atributos/propriedades e funções/métodos disponíveis para determinado
tipo de dado ou variável.

help (tipo de dado/variável.propriedade())


- "q" sai do help
- Podemos fazer direto no terminal ou aqui no script

Faça no terminal:
print(dir("sorte"))

No terminal os dados saem muito melhor.
"""

------------------------------------------------------------------------------------------------------------------

"""
                        RECEBENDO DADOS DO USUÁRIO - TODO DADO RECEBDIDO VIA INPUT É DO TIPO STRING


Outros exemplos de string:
- aspas simples
    'Palavra'
- aspas duplas
    "Palavra"
- aspas simples triplas
    '''Palavra'''
- aspas duplas triplas
    ""Palavra""     # só não coloquei as três aspas duplas, de fato, para não dar erro aqui no python, haja vista já ter
aspas duplas e triplas logo abaixo.
"""

# Entrada de dados
# Podemos fazer esse input em apenas uma linha. Muito mais elegante
# print("Qual é o seu nome?")
# nome = input()

nome = input('Qual o seu nome? ')

# Exemplo de print antigo
# print('seja bem vindo(a) %s' % nome)

# Exemplo de print moderno
# print('seja bem-vindo(a) {0}'.format(nome))

# Exemplo de print 'mais atual'. Perceba que o f é de >>format. Eu prefiro usar este
print(f'Seja bem-vindo(a) {nome}!')

# Podemos fazer esse input em apenas uma linha. Muito mais elegante
# print('Qual sua idade?')
# idade=input()

idade = input('Qual a sua idade? ')

# Saída
# Exemplo de print antigo
# print('O %s tem %s anos' % (nome,idade))

# Exemplo de print moderno
# print('O(a) {0} tem {1} anos'.format(nome,idade))

# Exemplo de print 'mais atual'. Percebe que o f é de >>format
print(f'O(a) {nome} tem {idade} anos, ou seja, nasceu em {2021-int(idade)}.')


"""
- O int(idade) => cast
- Cast é a conversão de um tipo de dado. Ou seja, conseguimos subtrair uma string de um número (percebeu?)
- Podemos fazer cálculos dentro das chaves
- É importante notar que eu poderia tirar esse int aqui de baixo e colocar lá no input da idade, antes do input, para
transformar em inteiro logo no início

Nota:
Achei o jeito atual muito mais maneiro e profissional. A coisa está ficando boa.
"""

------------------------------------------------------------------------------------------------------------------

"""
                                                TIPO NUMÉRICO


- Formas de obter um número inteiro: int(5/2) ou no modo pythônico 5//2
- Obter o resto da divisão: 5%2

Obs.: se o resto da divisão de um número por 2 for 0, ele é par. Por outro lado, se o resto da divisão de um número por
2 for 1, é ímpar.

Exponenciação: 2**3
Em java, o limite de número inteiro é 2**63. Aqui, no python, o limite é a memória do seu computador.

- Para limpar o console do Python no terminal: CTRL+L
- Uma forma fácil de escrever um número difícil de visualizar: 1_000_000_000

    n+=1 é equivalente: n=n+1
    n-=1 é equivalente: n=n-1
    n*=1 é equivalente: n=n*1
    n/=1 é equivalente: n=n/1

- Observe que tem um padrão nesse formato de abreviação de operação que acabamos de ver. Veja que a operação vem antes
do sinal de igualdade
- Para saber que tipo de variável temos: type(variável) no Python Console
"""

------------------------------------------------------------------------------------------------------------------

"""
                                                        TIPO FLOAT


- Ou seja, tipo real, decimal
- Aqui no Python o separador de casas decimais é um ponto (.)
- Ao converter valores tipo float para inteiros perdemos precisão. Lembre-se de cálculo numérico
- Número complexo sempre tem um "j" acompanhado
- Podemos também passar um número inteiro para ponto flutuante, basta: float(num)
"""

# É possível fazer dupla atribuição aqui no python:

n1, n2 = 25.1, 33.2
print(f'O desempacotamento para n1 = {n1}')
print(f'O desempacotamento para n2 = {n2}')

------------------------------------------------------------------------------------------------------------------

"""
                                                    TIPO BOOLEANO


- Esse tipo vem da álgebra booleana, criada por George Boole
- Para o tipo booleano temos duas constantes, verdadeiro ou falso
    True: verdadeiro
    False:falso

Nota:
Não podemos usar letras minúsculas para representar "True" ou "False".
Usado também para operações básicas.
"""

ativo = False

print(ativo)
print('-----')

# Operações básicas

# Negação (not):

"""
Fazendo a negação, se o valor booleano for verdadeiro o resultado será falso,
se for falso o resultado será verdadeiro. Ou seja, sempre ao contrário.
"""

print(not ativo)
print('-----')

# Ou (or):

"""
Retorna um valor verdadeiro:

True or True: True
True or False: True
False or False: False
"""
logado = False
print(ativo or logado)
print('-----')

# E (and)
"""
Ambos os valores devem ser verdadeiros, mas a recíproca não é verdadeira. Confira no último boobleano (False and False).

True and True: True
True and False: False
False and False: False
"""

print(ativo and logado)
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
                                                    TIPO STRING


Sempre que:
- Estiver entre aspas simples
- Estiver entre aspas duplas
- Estiver entre aspas simples triplas
- Estiver entre aspas duplas triplas
- Dados de input

Nota:
O mais comum é usar aspas simples.
Se quisermos pular uma linha dentro de uma string, basta colocar: \n

A primeira posição de uma lista é o 0, diferente do MatLab que inicia com 1.
"""

nome = 'Francisco \nAraújo \nda \nSilva'
print(nome)
print(type(nome))
print('-----')

# Podemos fazer assim também, mas tem que ser com três aspas duplas

nome1 = """Pulando
Francisco
Araújo
da
silva
"""
print(nome1)
print(type(nome1))
print('-----')

nome2 = "Francisco \"Araújo\" "  # Uma maneira elegante de inserir aspas dentro de uma string
# print(nome2.lower())  # Transforma tudo em minúsculo
print(nome2)
print('-----')

print(nome2[0:9])  # Uma maneira de capturar um dado, conhecido como Slice de String
print(nome2.split())  # Transforma a variável 'nome2' em uma lista de string ['Francisco', '"Araújo"']
print(nome2.split()[0])  # Pegamos o primeiro elemento dessa lista, já que o "0" é a primeira posição
print(nome2.split()[1])  # Pegamos o segundo elemento da lista
print('-----')

# Invertendo as letras de uma string

print(nome2[::-1])  # Ou seja, vamos do primeiro até o último (::) e invertemos (-1)
print('-----')

# Podemos também trocar uma letra por outra
print(nome.replace('F', 'FF'))  # Ou seja, trocamos F por FF
print('-----')

texto = 'socorram me subino onibus em marrocos'  # Palíndromo. haha legal
print(texto)
print(texto[::-1])
print('-----')

print("""Francisco "Araújo" """)  # Outro Jeito de escrever aspas dentro de uma string

------------------------------------------------------------------------------------------------------------------

"""
                TIPO NONE - EM PYTHON REPRESENTA O TIPO SEM TIPO. ALÉM DISSO, PODE SER DO TIPO VAZIO


- É sempre específicado pela primeira letra maiúscula.
- Podemos usar esse tipo quando queremos criar uma variável e inicializá-la com um tipo 'sem tipo' antes de recebermos o
valor final.
"""

numeros = None
print(numeros)
print(type(numeros))
print('-----')

numeros = 1.44, 1.34, 5.67
print(numeros)
print(type(numeros))

------------------------------------------------------------------------------------------------------------------

"""
                                            ESCOPO DE VARIÁVEIS


Escopo é a limitação de algo. Ou seja, o local nossa variável será reconhecida dentro do nosso código. Temos dois
casos:

    - VARIÁVEIS GLOBAIS: seu escopo compreende no programa inteiro
    - VARIÁVEIS LOCAIS: reconhecidas apenas no bloco onde foram declaradas

Para declarar variáveis em python:
    - Nome_da_variavel = valor_da_variavel

Python é uma liguagem de tipagem dinâmica, ou seja, quando declaramos uma variável, não determinado qual tipo de dado
ela é.

Linguagens onde é necessário declarar o tipo de dado.
        Se fosse em linguagem C:
        int numero = 42

        Se fosse em linguagem Java:
        int numero = 42

Nessas linguagens, uma vez que a variável é declarada, não podemos mudar. No entanto, aqui no python podemos fazer
retribuição, por isso é uma linguagem de tipagem dinâmica.

Por exemplo:

if numero > 10:
    novo = numero + 10
    print(novo)  # Dentro do bloco

print(novo)  # Fora do bloco

Veja que a variável 'novo' está apenas dentro do laço. Ou seja, ela só existe lá, por isso ela é uma variável local.

Nota:
Um exemplo de variável de escopo não global é aquela que pode estar dentro de um if apenas, por exemplo.
"""

numero = 42  # Exemplo de variável global. Posso acessar essa variável em qualquer parte do código
print(numero)
print(type(numero))
print('-----')

if numero > 10:
    novo = numero + 10
    print(novo)  # Ela vai existir apenas aqui dentro do código

------------------------------------------------------------------------------------------------------------------

"""
                  ///Espaço reservado para solucionar alguns exercícios da seção 4///
"""
# 1 - Faça um program que leia um número inteiro e o imprima
# a = input('Digite um número inteiro: ')
# print(f'O número inteiro é: {a}')
# print('-----')

# 2 - Faça um programa que leia um número real e o imprima
# b = 2.2
# print(f'O número real é: {b}')
# print('-----')

# 3 - Peça ao usuário para inserir três números inteiros e imprima a soma deles
# c = input('informe o primeiro número inteiro: ')
# d = input('informe o segundo número inteiro: ')
# e = input('informe o terceiro número inteiro: ')
# print(f'A soma dos três números inteiros é: {int(c)+int(d)+ int(e)}')
# print(f'A soma dos três números inteiros é: {c+d+e}')  # veja que aqui não estamos somando, estamos concatenando os n°
# Lmbrar também que sem os "int" o dado é tipo string, devido ao input, por isso precisamos fazer um cast
# print('-----')

# 4 - Leia um número real e imprima o resultado do quadrado desse número
# f = 3
# print(f'O quadrado do número real é: {f**2}')
# print('-----')

# 5 - Leia um número real e imprima a quinta parte desse número.
# g = 5
# print(f'A quinta parte do número {g} é: {(1/5)*g}')
# print('-----')

# 6 - Leia uma temperatura em graus Celsius e apresente-a convertida em graus Fahrenheit.
# A fórmula de conversão é: F=C*(9/5)+32, sendo F a temperatura em Fahrenheit
# e C a temperatura em Celsius.
# h = 42
# print(f'A temperatura de {h} graus Celsius equivale a {h*(9/5)+32} graus Fahrenheit.')
# print('-----')

# 7 - Leia uma temperatura em graus Fahrenheit e apresente-a convertida em graus Celsius.
# A fórmula de conversão é: C = 5*(F - 32)/9, sendo C a temperatura em Celsius e F a temperatura em Fahrenheit
# i = 107.6
# print(f'A temperatura de {i} graus Fahrenheit equivale a {5*(i-32)/9} graus Celsius.')
# print('-----')

# 28
# valor1 = 10
# valor2 = 20
# valor3 = 30
# print(f'A soma dos quadrados dos três valores: {(valor1 * valor1) + (valor2 * valor2) + (valor3 * valor3)}')
# print('-----')

# 43
# valor_lido = 425
# print(f'Valor total a pagar com 10% de desconto: {valor_lido * .9} R$')
# print(f'Valor parcelado, 3x sem juros: {valor_lido/3} R$')
# print(f'Comissão do vendedor na compra a vista: {.05 * (valor_lido * .9)} R$')
# print(f'Comissão do vendedor na compra parcelada: {.05 * valor_lido}')
# print('----')

# 45 - Faça um programa para converter uma letra maiúscula em letra minúscula. Use a tabela ASCII para resolver.
# j = 'FRANCISCO ARAujo'
# print(j.lower())
# print('-----')

# 46 - Faça um programa que leia um número inteiro positivo de três dígitos (de 100 a 999). Gere outro número formado
# pelos dígitos invertidos do número lido.
# numero = str(123)
# print(f'O número {numero} invertido é: {numero[::-1]}')
# print('-----')

# 47 - Leia um número de 4 dígitos (de a 1000 a 9999) e imprima 1 dígito por linha.
# nm = 2234
# nm = str(nm)
# print(nm[0])
# print(nm[1])
# print(nm[2])
# print(nm[3])
# print('-----')

# 50 - Implemente um programa que calcule o ano de nascimento de uma pessoa a partir de sua idade e do ano atual
# idade = 25
# ano_atual = 2022
# print(f'Ano de nascimento do cidadão: {ano_atual-idade-1}')
# print('-----')

------------------------------------------------------------------------------------------------------------------

"""
                                                ESTRUTURAS CONDICIONAIS

Temos:
    - if
    - else
    - elif (para mais de duas estruturas condicionais
        elif = else+if. Se parece muito com o elseif do matlab
"""

idade = 15

if idade < 18:  # Veja que os dois pontos cria o bloco, e para o if a estrutura condicional é na frente
    print('Menor de idade!')
    print(f'{idade} anos')
elif idade == 18:  # Estrutura condicional na frente para o elif. Podemos ter vários "elifs"
    print('Tem 18 anos')
else:  # Estrutura condicional em baixo para o else
    print('Maior de idade!')
    print(f'{idade} anos')

"""
Note que no Python é muito mais limpo para escrever estruturas condicionais. Além disso, podemos ter vários "ifs" 
também, mas não é legal, pois fica muito poluído visualmente. Enfim, não é elegante.
"""

------------------------------------------------------------------------------------------------------------------

"""
                                             ESTRUTURAS CONDICIONAIS


Operadores binários:
    - and (e): ambos precisam ser verdadeiros
    - or (ou): ou um ou o outro precisa ser verdadeiro

Operadores unários:
    - not (não): o valor do booleano é INVERTIDO, ou seja, se for True, vira False, se for False, vira True. É uma
    negação, um operador de negação
    - is (é): é muito usado para COMPARAÇÃO como forma de pergunta, retorna True ou False

Obs.:
- É importante notar que o "if" verifica se uma expressão é verdadeira ou falsa
- Quanto mais alto o nível da programação, mais próximo da linguagem humana. Por outro lado, quanto mais baixo, mais
próximo da linguagem das máquinas

Veja, quando usamos a função integrada dir() no console do Python, temos "is" nas iniciais de algumas expressões.
Faça no seu terminal:
nome = 'Francisco'
dir(nome)  --> veja que lá temos várias propriedades começando com o "is"

faça:
nome.isupper()
nome.title()
"""

ativo = False
logado = False

if ativo or logado:  # O que ele está dizendo é: se ativo ou logado for True: Executa a ação. Lembrar da prop. de "or"
    print('Bem vindo usuário!')
else:
    print('Você precisa ativar sua conta, Por favor, cheque seu email.')
    print('-----')
if not ativo:  # Se ativo não for True
    print('Você precisa ativar sua conta. Por favor, cheque seu email!!!')
else:  # Se ativo for True
    print('Bem-vindo usuário!')
print('-----')

print(not True)
print(not False)
print('-----')

if ativo is False:  # Uma maneira redundante de fazer a análise
    print('Você precisa ativar sua conta.')
else:
    print('Bem-vnido usuário!')
print('-----')

if not ativo:  # Uma maneira pythônica de fazer a análise: se não está ativo você prescisa ativar sua conta
    print('Você precisa ativar sua conta.')
else:
    print('Bem-vindo usuário!')
print('-----')

# Ativo é True?
print(ativo is True)
# Ativo é False?
print(ativo is False)

------------------------------------------------------------------------------------------------------------------

"""
                  ///Espaço reservado para solucionar alguns exercícios da seção 5///
"""

# 1
# x = input('Digite o primeiro número: ')
# y = input('Digite o segundo número: ')
# if x > y:
#     print(f'{x} é maior que {y}.')
# elif x < y:
#     print(f'{y} é maior que {x}.')
# else:
#     print(f'O número {x} é igual ao número {y}.')
# print('-----')


# 2
# x = float(input('Digite um número real: '))

# if x >= 0:
#     print(f'A raiz quadrada do número é: {x**0.5}')
# else:
#     print(f'O número não possui raiz real, já que {x} é negativo.')
# print('-----')

# 3
# x = float(input('Digite um número inteiro (Z): '))
# if x != int:
#     print(f"O número '{x}' será transformado em inteiro do tipo: {int(x)}")
#     if x % 2 == 0:  # Calculamos o resto da divisão com "%"
#         print(f'O número é par.\nA raiz quadrada: {(x**0.5)}')
#     else:
#         print(f'O número é impar.\nO número ao quadrado: {x**2}')
# else:
#     if x % 2 == 0:  # Calculamos o resto da divisão com "%"
#         print(f'O número é par.\nA raiz quadrada: {(x**0.5)}')
#     else:
#         print(f'O número é impar.\nO número ao quadrado: {x**2}')
# print('-----')

# 8
# nota1 = float(input('Insira a primeira nota: '))
# nota2 = float(input('Insira a segunda nota: '))

# if nota1 > 10 or nota1 < 0:
#     print(f'A nota {nota1} não é válida. Precisa estar entre 0 e 10.')
# elif nota2 > 10 or nota2 < 0:
#     print(f'A nota {nota1} não é válida. Precisa estar entre 0 e 10.')
# else:
#     print(f'A média aritmética: {(nota1+nota2)/2}')


# 11
# num = float(input('Insira um número inteiro maior que zero: '))
# if num != int and num > 0:
#     print(f"O número '{num}' será transformado em: {int(num)}")
# num = str(int(num))

# soma = []
# if int(num) > 0:
#     for i in num:
#         soma.append(int(i))
#     print(f'A soma dos algarismos: {sum(soma)}')
# else:
#     print(f"Número inválido.")


# 12 = Preciso refinar esse código
# numero = input('Digite um número inteiro: ')
# if int(numero) < 0:
#     print('O número é negativo.')
# else:
#     lista = list(range(0, int(numero)))
#     print(lista)
#     for i in lista:
#         if 10**i - int(numero) < 0.3:
#             print(f'O log de {numero} na base 10 é aproximadamente: {i}')


# 13 - Calcula a média ponderada.
# notaProva1 = 6
# notaProva2 = 6
# notaProva3 = 6
# pesoProva1 = 1
# pesoProva2 = pesoProva1
# pesoProva3 = 2
# listaPeso = [pesoProva2, pesoProva3, pesoProva1]  # Não sei o que houve, mas não consegui usar o comando list aqui.
# mediaPonde = ((notaProva1*pesoProva1)+(notaProva2*pesoProva2)+(notaProva3*notaProva3))/sum(listaPeso)
# if mediaPonde >= 10:
#     print(f'VOCÊ ESTÁ APROVADO. Sua nota: {mediaPonde}')
# else:
#     print(f'VOCÊ ESTÁ REPROVADO. Sua nota: {mediaPonde}')

# Acho que ele está errando na suposta análise do cálculo da média ponderada

------------------------------------------------------------------------------------------------------------------

"""
                                                    LOOP FOR


LOOP - repetição
FOR - umas das estruturas de repetição

- Utilizamos loops para iterar sobre sequências ou sobre valores iteráveis
- Dica para abrir a documentação de qualquer função: ctrl + (clique em cima da função)
- Podemos multiplicar uma string pelo nome

Dicas para concatenar:
    nome = 'Francisco'
    nome + ' Araújo
"""


nome = 'Francisco Araújo'  # Faça: nome[0] e veja que o primeiro elemento (F) dessa lista de string será retornado
print(f'O primeiro elemento da lista: {nome[0]}.')
print('-----')

lista = [1, 3, 5, 7, 9]
print(f'O tipo da lista: {type(lista)}.')
numeros = range(1, 10)  # Não é uma lista, é um range. Depois veremos como transformar um range em uma lista
print(f'O tipo da lista: {type(numeros)}.')
print('-----')

# Exemplo de for 1: iterando em uma string
for letra in nome:
    print(f'Iterando em uma string: {letra}')
print('-----')

# Exemplo de for 2: iterando em uma lista
for numero in lista:
    print(f'Iterando em uma lista: {numero}')
print('-----')

# Exemplo de for 3: iterando em um range
for numero in range(1, 10):  # Isso lembra muito o linspace. Obs.: O range não inclui o último n°, vai até o elemento 9
    print(f'Iterando em um range: {numero}')
print('-----')

# Agora vamos iterar relacionando cada índice da lista, como uma forma de referência

"""
Enumerate: Retorna índice e valor
((1, 'F'), (2, 'r'), (3, 'a'), (4, 'n'), (5, 'c'), (6, 'i'), (7, 's'), (8, 'c'), (9, 'o'), (10, '')...)
"""
nome = 'Dua Lipa'
for letra, indice in enumerate(nome):
    print(f"Com o índice 'letra' estamos captando a letra: {nome[letra]}")
print('-----')

for _, letra in enumerate(nome):  # Outra forma, quando não precisamos do índice, descartamos com o underline
    print(letra)
print('-----')

for dado in enumerate(nome):  # Retorna índice e valor
    print(dado)
print('-----')

for valor in enumerate(nome):
    print(valor[0])  # Somente os índices

# Vamos agora para um exemplo prático de como usar o laço for aqui Python

quantidade = int(input('Quantas vezes esse loop deve rodar? '))  # Com o int garantimos que o número seja inteiro
for n in range(0, quantidade+1):
    print(f'Imprimindo: {n}')
print('-----')

Nome = 'Um novo nome!'

for letra in Nome:
    print(letra, end='/')

# O end='' faz com que as impressões sejam feitas na mesma linha com um espaçamento pré-especificado

------------------------------------------------------------------------------------------------------------------

"""
                ENTENDENDO E EXPLORANDO RANGES - NÃO É UM LAÇO DE REPETIÇÃO, É MAIS UMA FUNÇÃO AUXILIAR


- Precisamos conhecer o loop for para usar bem os ranges
- Precisamos conhecer o range para trabalhar melhor com loop for
- Ranges são utilizados para gerar sequências numéricas, nõo de forma aleatória, mas sim de maneira específica
"""

# Formas gerais:
"""
# Forma 1:
range(valor_de_parada)
Obs.: valor_de_parada não inclusivo (início padrão em 0 e passo de 1 em 1)
"""

for num in range(12):  # Indo de 0 até 12-1
    print(num)
print('-----')

"""
# Forma 2:
range(valor_de_início, valor_de_parada)
Obs.: valor_de_parada não inclusivo (início padrão especificado e passo de 1 em 1)
"""

for num in range(2, 12):
    print(num)
print('-----')

"""
# Forma 3:
range(valor_de_início, valor_de_parada, passo)
Obs.: valor_de_parada não inclusivo (início padrão específicado e passo especificado)
"""

for num in range(0, 20, 4):
    print(num)
print('-----')

"""
# Forma 4:
igual a três, mas inversa.
range(valor_de_início, valor_de_parada, -passo)
"""

for num in range(20, 0, -1):
    print(num)

# Obs.: Para criar uma lista (a partir do range) no terminal, basta fazer: lista = list(range(12))

lista = list(range(20))
print(f'Tipo de dado: {type(lista)}')
print(f'Criado a partir do range e depois transformado em uma lista: {lista}')

------------------------------------------------------------------------------------------------------------------

"""
                 LOOP WHILE - É IMPORTANTE LEMBRAR DA EXPRESSÃO BOOLEANA E O CRITÉRIO DE PARADA


Forma geral:
while expressão_booleana:
    //execução do loop

- O bloco while se repete enquanto a expressão BOOLEANA for verdadeira
- Expressão BOOLEANA é toda expressão onde o resultado é verdadeiro ou falso

ex.:
num = 5
Análise:
num < 5    False
num < 10   True

Ou seja, condições de verdadeiro ou falso.
"""

# Exemplo 1
numero = 10
while numero > 0:  # Ou seja, enquanto o 'numero' for maior que 0, executamos o código
    print(f'O número da vez é: {numero}')
    numero = numero - 1
print('-----')

"""
Obs.: Em um loop while é importante cuidar do critério de parada. Se a condição não for satisfeita, para "parar" é 
preciso clicar no stop do RUN.
"""

# Exemplo 2
resposta = ''  # Ou seja, o input da nossa variável será uma string
while resposta != 'sim' and resposta != 'Sim':  # Um modo de cobrir as duas possibilidades para S minúsculo e maiúsculo
    resposta = input('Já finalizou Francisco???: ')

print('Parabéns por ter finalizado Francisco!')  # Mensagem de saída quando o loop é finalizado

------------------------------------------------------------------------------------------------------------------

"""
                    SAINDO DE LOOPS COM BREAK - TANTO PARA LOOP FOR QUANTO PARA LOOP WHILE


"""

# Exemplo com o for
Parada = 15  # Nosso critério de parada
for numero in range(1, 20):
    if numero == Parada:
        break
    else:
        print(numero)
print(f"No número '{Parada}' saímos do loop!")  # Verificação
print('-----')

# Exemplo com o while
while True:  # Estamos forçando o loop infinito com True
    comando = input("Digite 'sair' para sair: ")
    if comando == 'sair':
        break
    else:
        if comando == 'Sair':
            break
print('Conseguimos sair do loop!')

# Nota: perceba que no loop while estamos cobrindo duas possibilidades (para s minúsculo e s maiúsculo)

------------------------------------------------------------------------------------------------------------------

"""
                  ///Espaço reservado para solucionar alguns exercícios da seção ///
"""

# 1: Múltiplos de 3
# lista = list(range(0, 500, 3))
# print(lista[0:5])
# print('-----')

# 2.1: Usando o for
# limite = 100
# for i in range(0, limite+1):
#     print(i)
#     if i == limite:
#         for h in range(0, limite+1):
#             print(h)
#             if h == limite:
#                 for m in range(0, limite+1):
#                     print(m)
# print('------')

# 2.2: Usando while
# limite = 0
# parada = 0
# while limite < 101:
#     limite += 1
#     print(limite)
#     if limite == 100:
#         limite = 0
#         parada += 1
#     print(limite)
#     if parada == 3:
#         break
# print('-----')

# 3: Contagem regressiva
# cont = 0
# while cont < 10:
#     cont += 1
#     print(cont)
# print('FIM')
# print('-----')

# 4: Com passos
# limite = int(input('Digite um valor inteiro maior que 10_000: '))
# olimite = 0
# while olimite < limite:  # Uma forma diferente de representar o valor 10000. É melhor para visualizar
#     olimite += 1_000
#     print(olimite)
# print('-----')


# 5
# n = 0
# lista = []
# while True:
#     n += 1
#     x = float(input('Digite o primeiro valor para somar no final: '))
#     lista.append(x)
#     if n == 10:
#         break
# print(' ')
# print(f'A soma dos valores: {sum(lista)}')
# print('-----')

# 7
# lista = [1, 10, -1, -2, 5, 6, 4, 3, 2, 5]
# positivos = []
# for i in lista:
#     if i > 0:
#         positivos.append(i)
# print(f'A média aritmética dos valores positivos: {sum(positivos)/len(positivos)}')
# print('-----')

# 8
# print(f'O menor valor lido da lista: {min(lista)}')
# print(f'O maior valor lido da lista: {max(lista)}')
# print('-----')

# 10: Somar os pares e positivos
# lista = [1, 10, -1, -2, 5, 6, 4, 3, 2, 5]
# lista_pares = []
# for i in lista:
#     if i > 0:
#         if i % 2 == 0:
#             lista_pares.append(i)
# print(f'A soma de todos os pares da lista: {sum(lista_pares)}')
# print('-----')


# 17
# inteiro = int(input("Digite um número inteiro para criar uma lista de 0 até ele: "))
# quantidades = int(input("Escolha o índice até onde devemos somar os elementos na lista: "))
# listint = list(range(0, inteiro))
# print(f'A soma dos números até o índice da lista: {sum(listint[0:quantidades])}')
# print(listint)
# print('-----')

# 18 - Não era o que o  exercício pedia, mas gostei depois de feito e resolvi não apagar. Tudo pela arte do código
# numeros = list(range(0, int(input("Insira um valor como índice para que uma lista seja criada de 0 até ele: "))))
# parada = int(input('Escolha até qual índice devemos contar: '))
# contagem = []
# print(numeros)
# print(f"O maior deles: {max(numeros)}")
# for i in numeros:
#     contagem.append(i)
#     if i == parada:
#         break
# print(f"Foram feitas '{len(contagem)}' leituras.")
# print('-----')

# 24
# divisores = []
# inteiro = int(input('Digite um número inteiro:  '))
# lista = list(range(1, inteiro))
# lista_divisores = []

# for i in lista:
#     if inteiro % i == 0:
#         lista_divisores.append(i)

# print(f'A soma dos divisores: {sum(lista_divisores)}')
# print(f'A lista dos divisores: {lista_divisores}')
# print('-----')

# 25
# lista = list(range(0, 1001))
# multiplos = []
# for i in lista:
#     if i % 3 == 0:
#         multiplos.append(i)
#     else:
#         if i % 5 == 0:
#             multiplos.append(i)

# print(f"A soma de todos os multiplos: {sum(multiplos)}")
# print(f"A lista de todos os multiplos: {multiplos}")
print('-----')

# 26
# numero = int(input('Digite um número: '))
# multiplos = [11, 13, 17]
# lista_multiplos = []
# for i in multiplos:
#     if numero % i == 0:
#         lista_multiplos.append(i)

# if len(lista_multiplos) > 0:
#     print(f'Os múltiplos: {lista_multiplos}')
# else:
#     if len(lista_multiplos) == 0:
#         print(f'Esse número não possui os seguintes múltiplos: {multiplos}')

# if len(lista_multiplos) > 0:
#     for i in lista_multiplos:
#         if numero > i:
#             print(f'O múltiplo mais próximo: {i}')
#         if numero < i:
#             print(f'O múltiplo mais próximo: {i}')

------------------------------------------------------------------------------------------------------------------

"""
                                            LISTAS - SÃO MUTÁVEIS


Listas: Em Python funciona como vetores/matrizes (arrays). Aqui, nossas listas são DINÂMICAS e podemos inserir QUALQUER
TIPO de dado nela.

No Python:
    - Dinâmico: não possuem tamanho fixo, ou seja, podemos criar e incrementar elementos, mas o tamanho não é infinito,
    depende do tamanho da memória da máquina que você está usando
    - Qualquer tipo de dado: não possuem tipo de dado fixo
    - Listas em Python são represetadas entre colchetes []
    - O python é uma das linguagens mais usadas no campo da biotecnologia

 Faça (no terminal): type([]): você será informado que o tipo é uma lista.

 Obs.: Faça dir(lista) no termina. Essa ação nos mostrará todos os métodos para essa variável do tipo lista (você vai
 criar essa lista e depois aplicar a ação).
"""

# from typing import List

print(type([]))
print('-----')

lista1 = [1, 2, 5, 6, 1, 4, 6, 12, 45]  # Lista de números inteiros
lista2 = ['F', 'r', 'a', 'n', 'c', 'i', 's', 'c', 'o']  # Lista de strings
lista3 = []  # Lista vazia
lista4 = list(range(11))  # Transforma os dados de zero a dez do range em uma lista
lista5 = list('Francisco Araújo')  # Gera uma lista com um único elemento do tipo string
print('-----')

# Podemos, facilmente, checar se um elemento esta na lista com a função "in"

n = 11
if n in lista1:
    print(f'Encontrei o valor {n} na lista!')
elif n-1 in lista1:
    print(f'O valor {n} não está na lista, mas econtramos o valor {n-1}, que é n - 1!')
elif n+1 in lista1:
    print(f'O valor {n} não está na lista, mas encontramos o valor {n+1}, que é n + 1!')
else:
    print(f"Valor '{n}' não foi encontrado na lista!")
print('-----')

# Podemos facilmente ordenar uma lista, de strings ou numérica. Não importa se houver elementos repetidos

lista1.sort()  # Uma vez ordenado, a lista anterior não existe mais, apenas a ordenada
print(lista1)
print('-----')

# Podemos contar o número de ocorrências de um valor em uma lista

print(f'Ocorrência no número "1" na lista 1: {lista1.count(1)}')
print(f"Ocorrência da letra 'a' na lista 5: {lista5.count('a')}")
print('-----')

"""
Podemos adicionar elementos em uma lista: Utilizando a função "append", inclusive valor repetido. Todavia, conseguimos
incrementar apenas um ELEMENTO (importante notar que uma lista também é um elemento) por vez.
"""

print(f'Lista 1: {lista1}')
lista1.append(1)
print('Adicionamos o número 1 na lista1:')  # Essa adição de elemento é feita no final da lista
print(lista1)
print('Usamos [] para incrementar uma lista dentro de outra lista.')
lista1.append([1, 2, 3, 4, 5, 6, 7])
print(lista1)
print('-----')

# Mas atenção! Cuidado ao procurar dados nessa lista, já que ela possui mais de um tipo de elemento

if [1, 2, 3, 4, 5, 6, 7] in lista1:
    print('Ótimo, encontrei a lista incrementada (o elemento lista na verdade)!')
else:
    print('Não encontrei o elemento lista! Verifique novamente!')
print('-----')

# Como encontrar um elemento que está na lista incrementada?

n = 3
if n in lista1[len(lista1) - 1]:  # Acessando a última posição da lista, que é a lista que contém nosso elemento
    print(f'Encontrei o elemento "{n}" na lista 1 incrementada!')
else:
    print(f'Não encontrei o elemento "{n}" na lista 1 incrementada!')
print('-----')

"""
Raciocínio para o if acima:
A função len conta quantos elementos temos na lista, ou seja, 11 elementos. No entanto, como o Python possui posição
0, nossa lista incrementada está na posição 10, por isso acessamos ela na posição [len(lista1) - 1] = 10
"""

"""
Outra forma de adicionar elementos na lista, mas são adicionados individualmente. Ou seja, a lista continuará com 1 
elemento.
Outro detalhe importante é que essa função não aceita valor único. Para isso temos que usar o append().
"""

lista1.extend([1, 2, 3, 4, 5, 6, 7])
print(lista1)
print('-----')

# Podemos inserir (e não substituir) um elemento na lista especificando a posição do elemento na lista

print(f'Lista 1: {lista1}')
lista1.insert(2, 'Elemento adicionado na terceira posição com a função insert')
print(lista1)
print('-----')

# Podemos também juntar duas listas

lista6 = lista1 + lista2  # Faz o mesmo trabalho do extend
print(lista6)
print('-----')

# Podemos inverter uma lista

lista1.reverse()
lista2.reverse()
print(lista1)
print(lista2)
print('-----')

# Outro jeito de inverter

print(lista5[::-1])
print('-----')

# Podemos copiar uma lista

lista7 = lista6.copy()
print(lista7)
print('-----')

# Podemos saber quantos elementos temos na

print(f'A lista7 tem {len(lista7)} elementos')
print('-----')

# Podemos excluir o último elemento da lista. O pop remove e retorna o último elemento. Verifique no terminal

print(lista5)
lista5.pop()
print(lista5)
print('-----')

"""
Podemos também remover pelo índice. Os elementos a direita do índice são deslocados para a esquerda. Com isso, novos
índices são criados. Esse detalhe é muito importante.
"""

print(lista5)
lista5.pop(1)
print(lista5)
print('-----')

# Podemos remover todos os elementos

print(lista5)
lista5.clear()
print(lista5)
print('-----')

# Repetindo uma lista

nova = [1, 2, 4, 6, 8, 0]
nova = nova * 3
print(nova)
print('-----')

# Posso transformar um texto (string) numa lista a cada espaço (se não especificado no argumento do split) da expressão

nova = 'Francisco Araújo da Silva'
print(nova.split())
print('-----')

# Para separar a cada vírgula
nova = 'Francisco,Araújo,da,Silva'
print(nova.split(','))
print('-----')

# Concatenando elementos de uma lista por espaço e transformando em uma string. Será que vale apenas para string?

umTexto = ['Francisco', 'Araújo', 'da', 'Silva']
umaString = ' '.join(umTexto)
print(umaString)
print('-----')

# Numa lista, realmente, podemos colocar qualquer tipo de dado

listaVariada = [1, 2.32, True, 'Francisco', 'd', [1, 2, 3], 45462656]
print(listaVariada)
print('-----')

# Exemplo 1 com o for. Agora, vamos iterar em uma lista. Ou seja, vamos imprimir cada elemento

for elemento in listaVariada:
    print(elemento)
print('-----')

"""
# Exemplo 2 - usando o while.
carrinho = []  # Criamos uma lista vazia
produto = ''  # Variável do tipo string, para adicionar ao carrinho

while produto != 'sair':
    print("Adicione um produto na lista ou digite 'sair' para sair e exibir o carrinho de produtos: ")
    produto = input()
    if produto != 'sair':
        carrinho.append(produto)
for produto in carrinho:
    print(f'Todos os produtos adicionados ao carrinho são: {produto}')
"""
print('-----')

# Podemos também criar uma lista com variáveis. Isso pode ser muito interessante

numeros = [1, 2, 3, 4, 5]
print(numeros)

num1 = 1
num2 = 2
num3 = 3
num4 = 4
num5 = 5

numerosV = [num1, num2, num3, num4, num5]
print(numerosV)
print('-----')

# Nas listas, fazemos acesso aos elementos de forma indexada (via índice)

cores = ['verde', 'amarelo', 'azul', 'branco']

print(cores[0])  # verde
print(cores[1])  # amarelo
print(cores[2])  # azul
print(cores[3])  # branco
print('-----')

"""
Podemos, também, acessar de trás para frente. Pense nas listas como um círculo, pode ajudar a acessar os elementos nessa
ordem.
"""

print(cores[-1])  # branco
print(cores[-2])  # azul
print(cores[-3])  # amarelo
print(cores[-4])  # verde
print('-----')

# Loop nas cores com for

for cor in cores:
    print(f'As cores com o loop for: {cor}')
print('-----')

# Loop nas cores com o while

indice = 0
while indice < len(cores):
    print(f'As cores com o loop while: {cores[indice]}')
    indice = indice + 1  # == indice += 1
print('-----')

cores = ['verde', 'amarelo', 'azul', 'branco']

# Podemos gerar índices em uma lista

for indiceDaLista, cor in enumerate(cores):
    print(f"índice da lista: {indiceDaLista}, Cor no índice:  {cor}")
# Ou seja, o  enumerate gera pares, chave e valor para a lista. A chave vair para "indiceDaLista" e valor para "Cor"

"""
Faça no terminal: cores = ['cor1', 'cor2', 'cor3', 'cor4', 'cor5', 'cor6', 'cor7']
list(enumerate(cores))
"""
print('-----')

# Lista aceita valores repetidos (reforçando)

lista = list([])

"""
Com o append() abaixo vamos adicionar elementos nessa lista vazia.
Essa declaração de lista, para criar lista vazia, é o jeito correto de criar sem gerar a cobrinha em baixo dele.
"""

lista.append(3)
lista.append(2)
lista.append(5)
lista.append(0)
lista.append(8)
lista.append(8)
lista.append(7)
print(lista)
print('-----')

"""
Agora vamos aprender outros métodos, mas não tão importantes, para continuar trabalhando com listas.
"""

# Encontrar o índice de um elemento em uma lista. Se o elemento não estiver na lista, UM ERRO É GERADO

lista10 = [1, 3, 5, 6, 3, 8, 9, 5, 4, 7]
print(f'O índice: {lista10.index(5)}')
print(f'O índice: {lista10.index(6)}')
print(f'O índice: {lista10.index(3)}')  # Gera o índice da primeira ocorrência, por isso, atenção se existir repetição
print('-----')

# Podemos fazer buscas dentro de um range, indicando qual o índice do ínicio da busca

print(lista10.index(3, 2))
# Procura o valor 3, a partir do índice 2. Ou seja, dentro de um range, busca o índice de acordo com a lista original
print('-----')

# Podemos fazer buscas dentro de um range. Valor, início, fim.

print(lista10.index(6, 2, 7))
print('-----')

# Revisando o slicing

# lista[início:fim:passo]. Parece com o range(início:fim:passo)

# Trabalhando com slice de lista com o parâmetro 'início'

lista = [1, 2, 3, 4, 5]
print(lista[1:])  # Imprime a lista a  partir do índice 1, ou seja, a partir do 2. Também aceita valores negativos
print('-----')

# Trabalhando com o parâmetro fim

print(lista[:2])  # Imprime do início até o índice 2
print('-----')

# Trabalhando com início e fim

print(lista[1:3])  # Imprime do índice 1 até o índice 2
print('-----')

# Trabalhando com o passo. Podemos usar valor negativo para o passo

print(lista[1::2])  # Imprime de 1 até o final de 2 em 2
print('-----')

# Trocando os valores em uma lista de lugar

nome = ['Francisco', 'Araújo', 'da', 'Silva']
nome[0], nome[1], nome[2], nome[3] = nome[2], nome[1], nome[3], nome[0]  # Forma diferente de atribuição.
print(nome)
print('-----')

# Modo Pythônico alinhado. Inverte a lista

nome = ['Francisco', 'Araújo', 'da', 'Silva']
nome.reverse()
print(nome)
print('-----')

# Soma*, Valor Máximo*, Valor Mínimo*, Tamanho*
# Se os valores forem todos inteiros ou reais.

lista = [1, 2, 3, 4, 5, 6]

print(sum(lista))  # soma
print(max(lista))  # valor máximo
print(min(lista))  # valor mínimo
print(len(lista))  # tamanho da lista
print('-----')

# Podemos transformar uma lista (colchetes) em uma tupla (parênteses) - estudaremos mais adiante

lista = [1, 2, 3, 4, 5, 6]
print(lista)
print(type(lista))

tupla = tuple(lista)
print(tupla)
print(type(tupla))

"""
VISUALMENTE A ÚNICA DIFERENÇA SÃO OS COLCHETES E OS PARÊNTES. Mas tem mais coisas por trás de tudo isso. Em breve 
estudaremos afinco.
"""
print('-----')

# Fazendo o desempacotamento da lista. É importante notar que o número de variáveis deve ser igual ao len da lista
lista = [1, 2, 3, 4, 5, 6]
nu1, nu2, nu3, nu4, nu5, nu6 = lista
print(nu1)
print(nu2)
print(nu3)
print(nu4)
print(nu5)
print(nu6)
print('-----')

"""
Muito cobrado em entrevista. Copiando uma lista para outra (Shallow Copy e Deep Copy).
"""
# Deep Copy
lista = [1, 2, 3]
print(f'lista criada {lista}')

novalista = lista.copy()
print(f'Lista copiada {novalista}')

novalista.append(4)

print(f'Lista criada: {lista}')
print(f'Lista copiado com o copy() adicionando elemento com o append(): {novalista} ')

"""
Veja que são duas listas diferentes. Ou seja, é o Deep Copy.
lista.copy >> copia uma lista, mas sem vínculo. Em python é chamado de Deep Copy
"""
print('-----')

# Shallow Copy

lista = [1, 2, 3]
print(f'lista criada {lista}')

nova = lista  # Uma forma de cópia, que também é uma atribuição
print(f'lista copiada com vínculo {nova}')

nova.append(4)

print(f'lista criada {lista}')
print(f'lista copiada {nova}')

"""
Utilizamos a cópia via atribuição. Copiamos o dado da lista para uma nova lista. Todavia, ao modificar uma, modificamos 
a outra. Em Python é chamado de Shallow Copy.Isso é muito importante.
"""

------------------------------------------------------------------------------------------------------------------

"""
                    TUPLAS (TUPLE) - BASTANTE PARECIDAS COM LISTAS, MAS COM DUAS DIFERENÇAS BÁSICAS


- Aceita diferentes tipos de dados
- Tuplas são representadas por parênteses.
- Tuplas são IMUTÁVEIS, ou seja, ela nunca muda. Todas as operações em uma tupla gera uma NOVA tupla
"""

# Nota 1: As tuplas são representadas por parênteses (). Mas veja:

tupla1 = (1, 2, 3, 4, 5, 6)
print(tupla1)
print(type(tupla1))
print('-----')

tupla2 = 1, 2, 3, 4, 5, 6,  # Apenas com as vírgulas também criamos uma tupla. A vírgula no final é opcional
print(tupla2)
print(type(tupla2))
print('-----')

# Nota 3: Tuplas com 1 elemento, não é uma tupla, é um inteiro. Por isso o aviso sobre (1), dizendo que é redundante

tupla3 = (1)
print(tupla3)
print(f'Veja que é do tipo inteiro: {type(tupla3)}')
print('-----')


# Nota 4: Isso é uma tupla. Criamos com a vírgula

tupla4 = (1,)
print(tupla4)
print(type(tupla4))
print('-----')

tupla5 = 25,  # Também é uma tupla
print(tupla5)
print(type(tupla5))
print('-----')

# Em conclusão: tuplas são definidas pelo uso das vírgulas, e não pelo uso dos parênteses. Isso é importante

# Também podemos gerar tuplas com o range

tupla6 = tuple(range(20, -22, -2))
print(tupla6)
print(type(tupla6))
print('-----')

# Desempacotamento de tuplas. Funciona da mesma forma que as listas

tupla = ('Francisco', 'Araújo', 'da', 'Silva')
nome, sobre_nome, terceiro_nome, quarto_nome = tupla
print(nome)
print(sobre_nome)
print(terceiro_nome)
print(quarto_nome)
print('-----')

# Métodos para adição e remoção de elementos nas tuplas não existem, já que são imutáveis

# Se os valores forem inteiros ou reais: soma*, valor máximo*, valor mínimo*, tamanho*

tupla7 = 1, 1, 5, 6, 5, 4, 9, 8.1
print(f'soma: {sum(tupla7)}')
print(f'máximo: {max(tupla7)}')
print(f'mínimo: {min(tupla7)}')
print(f'tamanho: {len(tupla7)}')
print('-----')

# Concatenação de tuplas

tupla8 = 1, 2, 3,
print(tupla8)

tupla9 = 2, 5, 1
print(tupla9)

tupla10 = (tupla8 + tupla9)
print(tupla10)
print(type(tupla10))
print(tupla8)
print(tupla9)
print('-----')

# Tuplas são imutáveis, mas posso sobrescrever uma tupla. Informação importante

tupla8 = tupla8 + tupla9
print(f'Tupla 8 sobrescrita: {tupla8}')
print('-----')

# Podemos verificar se determinado elemento está em uma tupla

tupla11 = 2, 6, 4, 1, 2, 3, 6, 9,
print(1 in tupla11)  # Maneira interessante de fazer essa verificação
print(15 in tupla11)
print('-----')

# Iterando em uma tupla

for n in tupla11:
    print(n)
print('-----')

# Gerando índice para os elementos na tupla

for indice, valor in enumerate(tupla11):
    print(f'índice: {indice}', f'valor: {valor}')  # Gostei dessa opção
print('-----')

# Contando elementos dentro de uma tupla

tupla12 = ('a', 'b', 'a', 'c', 'd', 'f', 'g', 'l', 'a', 'k', 'j', 'e', 'a', 'i', 'b')
elemento = 'b'
print(f"Possui '{tupla12.count(elemento)}' elementos '{elemento}' na tupla em estudo!")
print('-----')

# Posso transformar uma string em uma tupla

umaString = 'Francisco Araújo'
print(umaString)
print(type(umaString))
print('-----')

umatupla = tuple(umaString)
print(umatupla)
print(type(umatupla))
print('-----')

# Exemplos para o bom uso de tuplas

# Exemplo 1: meses, já que nunca mudam

meses = ('jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez')
print(meses)
print('-----')

# Como acessar o elemento de uma tupla?

print(meses[3])  # Ou seja, é indexado
print('-----')

# Iterando sobre uma tupla

indice = 0
while indice < len(meses):
    print(meses[indice])
    indice += 1
print('-----')

# Qual o índice do elemento?

print(meses.index('fev'))
print('-----')

# Slicing: tupla[inicio:fim:passo], ou seja, mesmo usando tuplas, temos que usar colchetes para o slicing

print(meses[5:8])

"""
- Porque utilizar tuplas? são mais rápidas do que listas. Ótimo para big data, AI. Ganhamos performance
- Tuplas deixam seu código mais seguro, já que os elementos imutáveis trazem segurança para o código
"""
print('-----')

# Copiando uma tupla para outra

tupla = (1, 2, 3)
print(f'Primeira tupla: {tupla}')

nova = tupla

print(f'Nova tupla: {nova}')
print(f'Primeira tupla: {tupla}')

outra = (3, 4, 0)

nova = nova + outra  # Na tupla não temos o diferencial da Shallow Copy. Ou seja, não tem vínculos aqui na tupla

print(f'nova + outra: {nova}')
print(tupla)

------------------------------------------------------------------------------------------------------------------

"""
                                                    DICIONÁRIOS


- Em algumas linguagens de programação, os dicionários Python são conhecidos por MAPAS.
- Dicionários são coleções do tipo chave/valor. Ou seja, mapeamento entre chave-valor
- Dicionários são representados por {}, faça: print(type({}))
- O conjunto chave-valor pode ser de qualquer tipo (podemos misturar dados), e seprados por ':'
Ex.: chave:valor
"""

# Criação de dicionários

# Forma 1: A mais comum. O conjunto chave-valor é um elemento, portanto, temos três elementos. Recomendado

# paises = {'br': 'Brasil', 'eua': 'Estados Unidos', 'py': 'Paraguai'}
# print(paises)
# print(type(paises))

# Forma 2: Menos comun, mas acho essa melhor. Observe que o dicionário é criada pela palavra reservada, e não pelo "{}"

paises = dict(br='Brasil', eua='Estados Unidos', py='Paraguai')
print(paises)
print(type(paises))
print('-----')

# Acessando elementos. Lembrar que eles NÃO são indexados

# Forma 1: Acessando via chave, da mesma forma que lista/tupla

print(paises['br'])
print(paises['py'])  # Gera um erro se a chave não existir, keyerror, tratar o erro é mais complicado
print('-----')

# Forma 2: Acessando via get - RECOMENDADO, pois não gera erro, gera None se a chave não existir

print(paises.get('br'))
print(paises.get('ru'))  # Gera um aviso tipo None (não um erro), se o valor não for encontrado
print('-----')

# Imagine a aplicação abaixo. Veja a vantagem de usar o None a partir da forma 2.

novosPaises = dict(br='Brasil', eua='Estados Unidos', py='Paraguai')
pais = novosPaises.get('pa', 'PAÍS NÃO ENCONTRADO!')

"""
Olha aí, é mais vantajoso usar o elemento get. Assim, nem precisaríamos mais do if e do else. Posso deixar um recado se 
não encontrar o valor. Esse detalhe é muito importante.
"""

print(f'Encontrei o país {pais}!')
print('-----')

"""
if russia:
    print(f'Encontre o país {novosPaises}!')
else:
    print('Não encontrei o país!')
"""
print('-----')

# Podemos verificar se uma CHAVE está dentro do dicionário

print('br' in novosPaises)  # Está no dicionário, True
print('ru' in novosPaises)  # Não está no dicionário, False
print('Estados Unidos' in novosPaises)  # 'Estados Unidos' está no dicionário, mas não é chave, False
print('-----')

"""
Podemos utilizar qualquer tipo de dado (int, float, string, booleano), incluisive lista, tupla dicionário, como 
sendo as chaves dos dicionários.
"""

# Ex.: Localidades com as respectivas coordenadas geográficas (fictícias)

localidades = {
    (35.6565, 6365.656): 'Escritório em Tókio',
    (40.6652, 4569.632): 'Escritório em Singapura',
    (63.3215, 7849.5623): 'Escritório em Londres',
}

print(localidades)
print(type(localidades))

"""
Veja, em localidades, usamos tuplas como chaves para o nosso dicionário. A tupla é uma boa tática para usar como chave
de dicionário, já que ela é imutável.
"""
print('-----')

# Adicionar elementos em um dicionário

receita = {'jan': 100, 'fev': 120, 'mar': 300}
print(receita)
print(type(receita))
print('-----')

# Forma 1: Mais comum e mais fácil

receita['abr'] = 350  # muito simples
print(receita)

# Forma 2: Boa também

novo_dado = {'mai': 500}
receita.update(novo_dado)  # Achei essa forma 2 muito top. receita.update({'mai': 500}) - é a mesma coisa
print(receita)
print('-----')

# Atualizando/modificando dados em um dicionário

# Forma 1

receita['mai'] = 550
print(receita)

# Forma 2

receita.update({'mai': 600})
print(receita)
print('-----')

"""
CONCLUSÃO1: A forma de adicionar elementos em um dicionário ou atualizar dados em um dicionário é a mesma.
CONCLUSÃO2: Em dicionários, NÃO podemos ter chaves repetidas. Já que se isso ocorrer, estamos, na verdade, atualizando.
"""

# Removendo dados de um dicionário

receita = {'jan': 100, 'fev': 120, 'mar': 300}
print(receita)

# Forma 1: Mais comum (retorna o valor removido), preciso indicar o índice se não for o último elemento

ret = receita.pop('mar')  # O pop remove o último (na forma padrão) elemento da lista. Aqui, precisamos indicar a chave
print(f'O VALOR retirado com o pop é sempre mostrado: {ret}')
print(receita)
print('-----')

# Forma 2: Mais interessante, mas não retorna o valor removido. A vantagem é que não preciso indicar o índice da chave

del receita['jan']
print(receita)
print('-----')

# Porque usar dicionários?

# Imagine que você tem um comércio eletrônico, onde temos carrinhos de compras para adicionar produtos

"""
Carrinho de compras:
    Produto 1:
        - nome;
        - quantidade;
        - preço;
    Produto 2:
        - nome;
        - quantidade;
        - preço;
"""

# Poderíamos usar uma lista para isso? Sim! Mas não saberíamos quais são os índices (descrição do elemento)

Carrinho = []
Produto1 = ['Xadrez', 1, 230.00]
Produto2 = ['Pincel', 1, 150.00]

Carrinho.append(Produto1)
Carrinho.append(Produto2)
print(Carrinho)  # Na verdade, é uma lista de lista. Temos 2 produtos. Cada produto tem 3 índices

# Teríamos que saber qual é o índice de cada informação no produto
print('-----')

# Poderíamos utilzar uma tupla para isso? Sim

Produto1 = ('Xadrez', 1, 230.00)
Produto2 = ('Pincel', 1, 150.00)

carrinho = (Produto1, Produto2)
print(carrinho)  # Também, teríamos que saber qual o índice de cada elemento nos 2 produtos
print('-----')

# Poderíamos utilizar um dicinário para isso? Sim, e com vantagem, pois temos a descrição do índice

carrinho = []
produto1 = {'Nome': 'Xadrez', 'Quantidade': 1, 'preço': 230.00}
produto2 = {'Nome': 'Pincel', 'Quantidade': 1, 'preço': 150.00}

carrinho.append(produto1)
carrinho.append(produto2)
print(carrinho)  # Temos os índices bem explícitos, rico em detalhes. Fica melhor para visualizar. Evita problemas

"""
Dessa forma, facilmente adicionamos ou removemos produtos no carrinho e em cada produto podemos ter a certeza sobre
cada informação.
Cada coleção possue suas particularidades, mas elas se completam.
"""
print('-----')

# Métodos de dicionários.


# No terminal, faça: dir({}) e veja os vários métodos

d = dict(a=1, b=3, c=4)
print(d)
print(type(d))

# Limpando o dicionário

"""
d.clear()
print(d)
"""

# Copiando um dicionário

novo = d.copy()  # Deep Copy
print(novo)
novo['d'] = 10

print(d)
print(novo)
print('-----')

# Forma 2: Shallow Copy - com vínculo

novo = d
print(novo)
novo['d'] = 10
print(d)
print(novo)
print('-----')

"""
Forma não usual de criação de dicionários:
outro = {}.fromkeys('chave', 'valor')  # Assim, para cada letra de 'chave' é uma chave para 'valor'. Mas não repete.
"""

outro = {}.fromkeys('A', 'B')  # Sempre teremos o mesmo valor para chaves diferentes
print(outro)
print(type(outro))
print('-----')

# Criando várias chaves

usuario = {}.fromkeys(['nome', 'pontos', 'email', 'profile'], 'desconhecido')
print(usuario)
print(type(usuario))

"""
O método fromkeys recebe dois parâmetros: um interável e um valor.
Ele vai gerar para cada valor do iterável uma chave e irá atribuir a esta chave o valor informado.
"""
print('-----')

# Outra dica
veja = {}.fromkeys(range(1, 11), 'novo')
print(veja)

------------------------------------------------------------------------------------------------------------------

"""
                                                        MAPAS


- Em Python são conhecidos como dicionários
- Dicionários são representados por chaves
"""

receita = {'jan': 100, 'fev': 250, 'mar': 400}

# Iterar sobre dicionários

# Pegando a chave

for chave in receita:
    print(chave)
print('-----')

# Ou, pegando o valor

for chave in receita:
    print(receita[chave])  # Aqui estamos querendo o valor da receita. Isso é muito importante
print('-----')

print(receita)
print('-----')

for chave in receita:
    print(f'Em {chave}: recebi o valor de {receita[chave]} R$')  # Outro exemplo muito útil. Importante
print('-----')

# Podemos pedir todas as chaves em um dicionário

print(receita.keys())

# Podemos acessar todos os valores em um dicionário

print(receita.values())
print('-----')

# Modo pythônico de trabalhar

for chave in receita.keys():
    print(receita[chave])
print('-----')

# Desempacotamento de dicionário. Outro detalhe importante

for chave, valor in receita.items():
    print(f'Chave={chave}\nValor={valor}\n')  # Gostei dessa manipulação
print('-----')


# Soma, valor máximo, valor mínimo, tamanho.

# Se os valores forem todos inteiros ou reais, daí a importância usar a propriedade "values()"

print(f' Soma dos valores: {sum(receita.values())}')
print(f' Valor máximo: {max(receita.values())}')
print(f' Valor mínimo: {min(receita.values())}')
print(f' O tamanho do dicionário: {len(receita)}')

------------------------------------------------------------------------------------------------------------------

"""
CONJUNTOS: MESMO PRINCÍPIO DA TEORIA DOS CONJUNTOS NA MATEMÁTICA:

Sets: no Python, os conjuntos são chamados de sets.
-Sets: não possuem valores ordenados
-Sets: não possuem valores duplicados (não gera erro, mas não duplica)
-Elementos não são acessados via índice. Ou seja, NÃO SÃO INDEXADOS
-São MUTÁVEIS, diferente das tuplas

- Os conjuntos são bons para:
    -armazenar elementos, mas sem se importar com a ordenção, chaves, valores e itens duplicados
    -referenciados com "{}". Lembrar que mapas também são representados por chaves. veja diferenças:

Diferenças entre conjuntos  (Set) e mapas (dicionários)
    -dicionárIo: chave/valor
    -conjunto: valor

Obs.: Podemos gerar sets para strings, listas, tupla, ...
Podemos obter muitas outras propriedades com o "dir" no console
"""

# Definindo um conjunto:
# Forma 1: menos comum
s = set({1, 2, 3, 4, 5, 5, 6, 7, 2, 3})  # temos valores repetidos, que serão descartados na geração do set

print(s)
print((type(s)))

"""
Obs.: Ao criar um conjunto, caso seja adicionado um valor existente, o mesmo será ignorado sem gerar error e não fará
fará parte do conjunto
"""
print('-----')

# Forma 2, mais comum
s = {1, 2, 3, 4, 5, 5}
print(s)
print((type(s)))
print('-----')

# verificando se determinado elemento está no conjunto
n = 10
if n in s:
    print(f'Tem o {n} no conjunto')
else:
    print(f'Não tem o {n} no conjunto')
print('-----')

# Algumas diferenças importantes sobre nossas coleções:

# Listas aceitam valores duplicados e mantém a ordem
lista = [99, 2, 34, 23, 2, 12, 1, 44, 5, 34]
print(f'Lista: {lista} com {len(lista)} elementos')

# Tuplas aceitam valores duplicados e mantém a ordem
tuupla = 99, 2, 34, 23, 2, 12, 1, 44, 5, 34
print(f'Tupla: {tuupla} com {len(tuupla)} elementos')

# Dicionários não aceitam chaves duplicadas e MANTÉM a ordem
diicionario = {}.fromkeys([99, 2, 34, 23, 2, 12, 1, 44, 5, 34], 'Valor')
print(f'Dicionário: {diicionario} com {len(diicionario)} elementos')

# Conjuntos não aceitam valores duplicados e gera uma ordem ALEATÓRIA
conjunto = {99, 2, 34, 23, 2, 12, 1, 44, 5, 34}
print(f'Conjuntos: {conjunto} com {len(conjunto)} elementos')
print('-----')

# Podemos colocar diferentes tipos de dados no conjunto
ss = {1, 'b', True, 32.32, 44}
print(ss)
print(type(ss))

# Podemos iterar um conjuntos
# Formas interessantes de usar os conjuntos:
"""
Formulário de um museu. Os visitantes visitam anualmente.
Adicionamos cada cidade em uma lista Python, já que em uma lista podemos adicionar novos elementos de forma a ter 
repetição.
Aplicação abaixo
"""
print('-----')

# No momento do cadastro
cidades = ['Belo Horizonte', 'Mato Grosso', 'Campo Grande', 'Cuiabá', 'Campo Grande', 'São Paulo', 'Cuiabá']
print(cidades)
print(f'Temos {len(cidades)} cadastros no museu')  # Agora sabemos quantos cadastros temos no museu
print('-----')

# Quantas cidades distintas temos? Vamos usar o set para isso. Essa é uma sacada importante
print(f'temos {len(set(cidades))} cidades distintas')
print('-----')

# Adiconando elementos em conjunto
# Forma 1: usando o add()
sss = {1, 3, 4, 5}
print(sss)
print(type(sss))

sss.add(6)
sss.add(6)  # duplicidade não gera erro
print(sss)
print(type(sss))
print('-----')

# Obs. : Não recomendo utilizar o update() nesse caso.
"""
sss.update({55})  # imprime com o valor 1
print(sss)  # imprime sem o valor 1 - mas ainda não sei qual a explicação para isso
print(type(sss))
print('-----')
"""

# Removendo elementos de um conjunto. Não retornamos valor que foi removido.

# Forma 1. GERA UM ERRO ao remover um elemento que não existe no conjunto
sss.remove(6)  # removemos o 6. Repare que não é via índice pelo fato de não ser indexado
print(sss)
print('-----')

# Forma 2. NÃO GERA UM ERRO ao remover um elemento que não existe no conjunto
sss.discard(1)  # importante usar esse modelo
print(sss)
print('-----')

# Copiando um conjunto para outro

# Forma 1 - Deep Copy. Ou seja, temos dois objetos independes
conj = {1, 3, 5, 7}
novo_conj = conj.copy()
print(novo_conj)
novo_conj.add(50)
print(conj)
print(novo_conj)
print('-----')

# Forma 1 - Shallow Copy. Aqui, quando mudamos em uma mudamos também na outra.
outro_conju = conj
outro_conju.add(100)  # Aqui no Shallow Copy estamos adicionando tanto no outroConj quanto no conj
print(conj)
print(outro_conju)
print('-----')

# Podemos remover todos os elementos no conjunto
outro_conju.clear()
print(outro_conju)
print('-----')

# Métodos matemáticos dos conjuntos
"""
Imagine que temos dois conjuntos: 
- Estudantes do curso de Administração Pública
- Estudantes do curso de Engenharia de Petróleo
"""
estud_Adm = {'Ana', 'Carla', 'Frederico', 'Francisco', 'Endriw'}
estud_EP = {'Francisco', 'Endriw', 'Henrique', 'Amanda'}

"""
Obs.: Observe que temos repetição nos nomes. Ou seja, estão nos dois conjutnos.
Precisamos gerar um conjunto com nome de elementos únicos.
"""
print('-----')

# Forma 1 - Utiizando union. Esse é recomendado, é mais explícito
unicos1 = estud_Adm.union(estud_EP)  # aqui a ordem não importa
print(f'Estudantes únicos via union(): {unicos1}')

# Forma 2 - Utilizando o caractere pipe "|"
unicos2 = estud_EP | estud_Adm
print(f'Estudantes únicos via pipe "|": {unicos2}')

# Gerar um conjunto de estudantes que estão em ambos os cursos
print('-----')
# Forma 1 - Utilizando intersection
ambos1 = estud_Adm.intersection(estud_EP)
print(f'Estudantes que estão em ambos os cursos via intersectiton(): {ambos1}')

# Forma 2 - Utilizando "&"
ambos2 = estud_Adm & estud_EP
print(f'Estudantes que estão em ambos os curso via &: {ambos2}')

# Agora, vamos gerar um conjunto de estudantes que não estão no outro curso. Ou seja, estão em um mas não em outro
print('-----')
apenas_EP = estud_EP.difference(estud_Adm)  # exclui os estudantes de Administração Pública
print(f'Apenas em Engenharia de Petróleo {apenas_EP}')
apenas_Adm = estud_Adm.difference(estud_EP)  # exclui os estudantes de Engenharia de Petróleo
print(f'Apenas em Administração Pública {apenas_Adm}')

# Soma, Valor máximo, Valor mínimo, Tamanho. Se os valores forem todos inteiros ou reais
print('-----')
s = {1, 3, 4, 5, 6, 7}
print(f'Soma dos valores do conjunto: {sum(s)}')
print(f'Valor máximo do conjunto: {max(s)}')
print(f'Valor mínimo do conjunto: {min(s)}')
print(f'Tamanho do conjunto: {len(s)}')

------------------------------------------------------------------------------------------------------------------

"""
MÓDULO COLLECTIONS: COUNTER (CONTADOR)

-temos que importar
-não confundir com o count(), usado no temas das listas
-collections -> conhecido como high-performance container datetypes
-todas as coleções são containers

Counter -> recebe um iterável como parâmetro e cria um OBJETO do tipo Collections Counter que é parecido com um
dicionário, contendo como chave o elemento da lista e, como valor, a quantidade de ocorrências desse elemento.

Importante para trabalhar com alguns framework
"""

# Usando o Counter. Estamos importando uma biblioteca. Podemos usar qualquer iterável. Aqui usamos uma lista
from collections import Counter
lista = [1, 1, 1, 2, 2, 3, 5, 6, 7, 7, 7, 7, 8, 9, 99, 100, 120, 150, 200, 400, 400, 400]

# Utilizando o Counter()
res = Counter(lista)  # se parece muito com um dicionário, mas não é
print(type(res))
print(lista)
print(res)  # Observe a falta de ordenação
print('-----')

"""
O que ele faz é: elemento: ocorrência
<class 'collections.Counter'>
Counter({7: 4, 1: 3, 400: 3, 2: 2, 3: 1, 5: 1, 6: 1, 8: 1, 9: 1, 99: 1, 100: 1, 120: 1, 150: 1, 200: 1})

Ou seja, criou uma chave e colocou como valor a ocorrência dos elementos no iterável.
Poderia ser uma string também.
"""

# Imprimindo direto
print(Counter('Francisco'))  # Observe a falta de ordenação lá no console
print('-----')

print(Counter(['Francisco', 'Araújo', 'da', 'Silva']))
print('-----')

# Exemplo mais completo
texto = """
Quem aspira se graduar na Engenharia de Petróleo precisa ter espírito arrojado, colaborativo e cooperativo e, sobretudo,
 entender a importância da cooperação e colaboração nas atividades cotidianas tendo em vista a promoção de ambientes 
 propositivos alinhados na consecução de objetivos comuns. Ademais, deve estar preparado para ampliar o entendimento da 
 realidade através do manuseio do repertório das ciências exatas e das engenharias.
"""

# Vamos separar essas palavras numa lista. O separador padrão é o espaço entre as palavras, mas posso escolher no
# split(' ')
palavras = texto.split()
print(palavras)
resp = Counter(palavras)
print(resp)

# Encontrando as 3 palavras com mais ocorrência no texto acima
print('-----')
print(resp.most_common(5))  # esse comando é muito interessante.

"""
Posso ver explição via terminal:
from collections import Counter
help(Counter)
"""

------------------------------------------------------------------------------------------------------------------

"""
MÓDULO COLLECTIONS: DEFAULT DICT:

Olha a diferença:
    recapitulando dicionários;
        dicionário = {'Curso': 'Engenharia de Petróleo'}
        print(dicionário)
        print(dicionário['Curso'])
        print(dicionário['Nome'])  # gera um keyError, já que essa chave não existe

    Default Dict - informamos um valor default, para não gerar erro se a chave não existe;
    Podemos usar o lambda para isso. Ou seja, sempre que não exisir um valor definido.
    Ao tentar utilizar uma chave que não existe, essa chave será criada e o valor default será atribuído.

Obs.: lambdas são funções sem nome, que podem ou não receber parâmetros de entrada e retornar valores
"""

# Importando
from collections import defaultdict
print(' ')
dicionario = defaultdict(lambda: 0)  # uma função lambda que não recebe argumento mas retorna zero.
print(dicionario)  # Imprime no estilo objeto
print(dict(dicionario))  # Imprime o objeto convertido em dicionário
print('-----')

dicionario['Curso'] = 'Petróleo'  # Criando a primeira chave e valor
print(dicionario)  # imprime no estilo defaultdict
print('-----')

print(dicionario['outro'])  # Mesmo não existindo, não gera KeyError, mas atribui o valor do lambada
print('-----')

print(dicionario)  # Agora vai atribuir a chave 'outro' com o valor '0' no dicionário.


------------------------------------------------------------------------------------------------------------------

"""
MÓDULO COLLECTIONS: ORDERED DICT.
"""
from collections import OrderedDict
# Em um dicionário, a ordem de inserção dos elementos não é garantida
dicionario = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
print(dicionario)
print('-----')

for chave, valor in dicionario.items():  # esse recurso é muito interessante
    print(f'Chave = {chave}: Valor = {valor}')
print('-----d')

dictionay = OrderedDict({'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5})

for chave, valor in dictionay.items():
    print(f'Chave = {chave}: Valor = {valor}')

# Entendendo a difereça entre Dict e Ordered Dict;

# Dicionários comuns
print('-----')

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 2, 'a': 1}
print(dict1 == dict2)  # True. A ordem dos elementos NÃO IMPORTA para o dicionário comum


# Ordered Dict
dict3 = OrderedDict({'a': 1, 'b': 2})
dict4 = OrderedDict({'a': 2, 'b': 1})

print(dict3 == dict4)  # False. A ordem dos elementos IMPORTA para o Ordered Dict

------------------------------------------------------------------------------------------------------------------

"""
MÓDULO COLLECTIONS: NAMED TUPLE

Named Tuple: são tuplas diferenciadas onde especificamos um nome para a mesma e também parâmetros
"""
from collections import namedtuple
# Precisamos definir o nome e parâmentros
# Forma 1 - Declaração Named Tuple
cachorro1 = namedtuple('cachorro', 'idade raca nome')  # O primeiro argumento é o nome da tupla

# Forma 2 - Declaração Named Tuple
cachorro2 = namedtuple('cachorro', 'idade, raca, nome')

# Forma 3 - Declaração Named Tuple. Esta forma é mais recomendada. Fica mais claro visualmente. Importante, top
cachorro3 = namedtuple('cachorro', ['idade', 'raca', 'nome'])

# Utilizando
# Forma 1 - Recomendado
Apoll = cachorro3(idade=1, raca='vira-Lata', nome='Apollo')
print(Apoll)
print(Apoll[0])  # idade
print(Apoll[1])  # raça
print(Apoll[2])  # nome

# Forma 2. Modo recomendado
print('-----')
print(Apoll.idade)
print(Apoll.raca)
print(Apoll.nome)

# Lembrando da aula de tupla:

print('-----')
print(Apoll.index('Apollo'))  # Índice do elemento na tupla
print(Apoll.count('Apollo'))  # Ocorrencias do valor na tupla

------------------------------------------------------------------------------------------------------------------

"""
MÓDULO COLLECTIONS: DEQUE

Podemos dizer que é uma lista de ALTO DESEMPENHO.
"""
from collections import deque

# Criando deques
deq = deque('Francisco')
print(deq)
print('-----')

# Adicionando elementos
deq.append(' Araújo')  # Da mesmo forma que adicionamos na lista
print(deq)
print('-----')

deq.appendleft('Silva')  # Adiciona no começo da lista. Uma vantagem
print(deq)
print('-----')

# Remover elementos
print(deq.pop())  # remove e retorna o último elemento da lista
print(deq)
print('-----')

print(deq.popleft())
print(deq)

------------------------------------------------------------------------------------------------------------------

"""
Espaço reservado pra solucionar os exercícios da seção 7 - parte 1
"""
"""
# 1
A = [1, 2, 3, 4, 5, 6]
print(A)
print('-----')
# a)
A.extend([1, 0, 5, -2, -5, 7])
print(A)
print('-----')

# b
print(f'A somas dos valores: {sum([A[0], A[1], A[5]])}')
print('-----')

# c
A.insert(4, 100)
print(A)
print('-----')

# d
for valor in A:
    print(f'Cada elemento da lista: {valor}')


# 3
reais = list([])
while len(reais) < 8:
    reais.append(float(input('Digite o próximo valor real para armazena na lista real: ')))

print(f'Os valores reais escolhidos: {reais}')
reais_quadrados = reais.copy()
quadrados = list([])
for i in reais_quadrados:
    quadrados.append(i**2)
print(f'Os valores reais ao quadrado: {quadrados}')
print('-----')
print(reais)
print(quadrados)


# 7
vetor = [1, 3, 4, 5, 8, 8, 10, 19, 34, 23]
maior = max(vetor)
print(f'O maior valor: {maior}\nEstá no índice: {vetor.index(maior)}')
"""
"""
# 14 - Esse é um desafio a se pensar
vetor = [1, 3, 4, 5, 8, 8, 1, 19, 34, 3]
valores_iguais = list([])
for i in vetor:


print(valores_iguais)
"""

------------------------------------------------------------------------------------------------------------------

"""
Espaço reservado pra solucionar os exercícios da seção 7 - parte 2
"""
------------------------------------------------------------------------------------------------------------------

"""
DEFININDDO FUNÇÕES:

- pode ou não receber entrada de dados e retornar uma saída de dados.
- muito usado para processos repetitivos.

OBS.:  Se a função criada realiza muitas tarefas, é bom fazer uma verificação para que a função seja simplificada.
Faça print(help(print())) para ver uma ducumentação ou ctrl+click no nome da função
"""
# exemplo de utilização de funções nativas (built-in):

cores = ['verde', 'amarela', 'azul', 'branco']
curso = ['Engenharia']

cores.append('roxo')  # adicionamos a cor "roxo" ao final da LISTA
curso.append('Administração Pública')
print('-----')

# utilizando a função integrada (Built-in) do Python print()

print(cores)
print(curso)
print('-----')

# cores.clear()  limpa a lista. Essa função não recebe dados de entrada
# print(cores)
print('-----')

# DRY - Don't Repeat Yourself (não repita você mesmo). Expressão muito usada na programação.

"""
Em python, a forma geral para definir função é:
def: definition

def nome_da_funcao(parametros_de_entrada):
    bloco_da_funcao
    
obs.:
nome_da_funcao: Sempre com letras minúsculas e separar com underline quando preciso.
parametros_de_entrada: São opcionais, se houver mais de um, separar por vírgula.
bloco_da_funcao: Também chamado de corpo da função, pode ou não ter o retorno da função.

Abrimos o bloco de código com o dois pontos ":"
Palavra reservada: def
"""
# Definindo a primeira função


def diz_oi():
    print('Olá usuário!')


"""
- Essa função "diz_oi" não recebe parâmetro de entrada.
- Essa função não retorna nada, pois fizemos apenas a definição dela.
- Podemos usar função dentro de outra função. Veja o "print", que está dentro da def.
"""

# Para utilizar essa função precisamos chamá-la
diz_oi()

# Veja que nunca podemos esquecer de usar o parênteses ao executar uma função. Lembrar também que ele é COLADO à função.
print('-----')


def cantar_parabens():
    print('Parabéns para você')
    print('Nesta data')
    print('Querida')
    print(' ')


# Chamando 3 vezes a mesma função.
cantar_parabens()
cantar_parabens()
cantar_parabens()
print('-----')


# or

for n in range(5):  # executando 5 vezes. A posição é n-1.
    cantar_parabens()
print('-----')

# or, mas não recomendado. Criando variáveis do tipo função. Executamos a variável como função.

cantar = cantar_parabens  # recebe a execução. Veja que não temos o parênteses. Esse método NÃO é comum.
cantar()

------------------------------------------------------------------------------------------------------------------

""""
FUNÇÕES COM RETORNO:

Obs.: Não precisamos criar uma variável para receber a variável de retorno. Podemos passar a
execução da função para outra função ou para o próprio print.

Posso importar minha função direto no terminal:
"from nomeDoArquivo import nomeDafunção"
nomeDafunção

O import abaixo será usado no fim do código.
"""
from random import random

numeros = [1, 2, 3]
ret_por = numeros.pop()  # pop remove e retorna o último elemento de uma lista. Mas nesse caso, não retorna diretamente.
print(f'Retorno de pop: {ret_por}')  # mostrando o elemento removido.
print('-----')

ret_pr = print(numeros)  # veja o erro (cobrinha).
print(f'O retorno de print: {ret_pr}')  # veja que a função print não retorna nada, daí o aviso.
print('-----a')


def quadrado_de_7():
    print(7 * 7)
    # só estamos imprimindo, mas não retornando. Muito cuidado com isso.  É diferente.


print('-----a')

rettt = quadrado_de_7()
print(f'O retorno do print: {rettt}')  # Veja que não retornamos nada com o print. É None. veja o erro (cobrinha).
print('-----')

# REFATORANDO (reescrevendo) o  problema. Ou seja, vamos dar uma melhorada no código.


def quadrado_de_8():
    return 8*8  # o return retorna o resultado.


rett = quadrado_de_8()  # veja que agora não temos mais erro. Já que agora possui retorno.

# diferentes formas de usar aquele resultado.
print(f'O retorno de 8 é: {rett}')
print(f'O retorno de 8 é: {quadrado_de_8()}')
print(f'O retorno de 8 é: {quadrado_de_8()*2}')
print('-----')

# veja que a grande sacada é o "return". Ou seja, o que retornamos agora é o valor do quadrado, e o erro desaparece.


def diz_oi():
    return 'Olá'
# Se fosse com um print não dava para somar lá em baixo, já que seria none.
# Se fosse print, não iriamos conseguir fazer cálculos com ele.


alguem = ' Lara!'
print(diz_oi() + alguem)  # Veja que o return oferece mais flexibilidade para usar variáveis.

"""
Notas:
1 - o return finaliza a função, ou seja, ela sai da execução da função.
2 - podemos ter diferentes return para a mesma função, mas apenas um é executado.
3 - podemos, em uma função, retornar qualquer tipo de dado e até múltiplos valores.
"""
print('-----')

# Exemplo 1 - Finalizando com return.


def diz_ola():
    print('Executado antes do return')  # executa
    return 'Olá'  # retorna
    print('Estou sendo executado? Não, pois está após o return')  # nunca será executado e retornado.


print(diz_ola())
print('-----a')

# Exemplo 2 - Diferentes returns.


def nova_funcao():
    variavel = None  # iniciando a variável.
    if variavel:  # se a variável for True, retorna 4, se for None, retorna 3.2, se for falso retorna 'Última opção'.
        return 4
    elif variavel is None:
        return 3.2
    return 'Última opção'


# veja que temos diferentes returns.
print(nova_funcao())
print('-----b')

# Exemplo 3 - retornando múltiplos valores.


def outra_funcao():  # número separado por vírgula são tuplas.
    return 2, 3, 4, 5


num1, num2, num3, num4 = outra_funcao()
# Seria tipo um desempacotamento de função. MUITO IMPORTANTE ISSO AQUI.

print(num1, num2, num3, num4)
print(type(print(num1, num2, num3, num4)))  # Veja que está sem tipo.
print('-----c')

# or
print(outra_funcao())  # retorna no formato tupla como foi definido na def.
print('-----d')

# vamos criar uma função para jogar a moeda.

# No terminal, dá para importar nosso script (o pacote) e qualquer função desse script, da mesma maneira.


def joga_moeda():
    # gera um número pseudo randômico entre zero e um. Pseudo, pois pode repetir.

    if random() > 0.5:
        return 'Cara'
    return 'Coroa'  # já tá fazendo o papel do else. IMPORTANTE ISSO AQUI.


print(joga_moeda())  # Para cada run, retornamos cara ou coroa
print('-----')


# codificações DESNECESSÁRIAS no return:
# %: verifica o resto da divisão
# !=: diferente


def e_impar():
    numero = 4
    if numero % 2 != 0:
        return True
    else:  # esse else é desnecessário
        return False


print(e_impar())

------------------------------------------------------------------------------------------------------------------

"""
FUNÇÕES COM PARÂMETROS:
entrada -> processamento -> saída
"""

# Refatorando uma função


def quadrado(numero):  # TypeError se não existir parâmetro
    # return numero * numero
     return numero ** 2


print(quadrado(10))
print(quadrado(20))
print(quadrado(30))
# Veja que o parâmetro no print é obrigatório.
print('------')

# Refatorando outra função


def cantar_para(Aniversariante):
    print(f'Parabéns {Aniversariante}')
    print('Nesta data')
    print('Querida')


cantar_para('Francisco')


# Exemplo com mais parâmetros
print('-----')


def somar(a, b):
    return a + b


def mult(num1, num2):
    return num1 * num2


def outra(num1, b, msg):
    return (num1 + b) * msg  # Veja que a mensagem vai se repetir pela quantidade da soma. Lembrar que  3*'palavra'=
# palavra palavra palavra


print(somar(2, 5))
print(somar(5, 5))

print(mult(2, 5))
print(mult(5, 5))

print(outra(2, 2, 'Francisco Araújo'))
print(outra(5, 5, 'Francisco Araújo'))

print('-----')

# Nomeando parâmetros, para facilitar a leitura do código para que deseja usar


def nome_completo(nome, sobrenome):  # Parâmetros (definição da função)
    return f'Seu nome completo é {nome} {sobrenome}'  # Olhe essa maneira de de trabalhar com esse print


print(nome_completo('Francisco', 'Araújo'))  # Argumentos (dados passados durante a execução da função)

# A ordem dos parâmtros importa.

# Argumentos nomeados (Keyword Arguments) ----- Posso colocar na ordem que eu bem desejar. Parece muito vantajoso
# Caso utilizemos nomes dos parâmetros nos argumentos para informá-los, podemos utilizar qualquer nome.
nome = 'Lara'
sobrenome = 'Cristina'
print(nome_completo(nome='Francisco', sobrenome='Araújo'))
print(nome_completo(nome=nome, sobrenome=sobrenome))
print(nome_completo(sobrenome='Limas', nome='Amanda'))

print('------')
# Erro comum na utilização do return


def soma_impares(numeros):
    total = 0
    for num in numeros:
        if num % 2 != 0:
            total = total + num
    return total  # veja que se dermos mais um tab, o if itera apenas uma vez, já que o return finaliza o passo


lista = [1, 2, 3, 4, 5, 6, 7]
print(soma_impares(lista))

tupla = (1, 2, 3, 4, 5, 6, 7)
print(soma_impares(tupla))

------------------------------------------------------------------------------------------------------------------

"""
FUNÇÕES COM PARÂMETRO PADRÃO (Default Parameters):

- Funções onde a passagem de parâmetro seja opcional;
- == representa igualdade, igual ao matlab

Quais tipos de dados podemos utilizar como valores default para parâmetro?
 - qualquer tipo: números, strings, floats, booleanos, listas, tuplas, dicionários, funcções, etc...
"""
print('Francisco Araújo')
print()  # Veja que a passagem de parãmetro para o print é opcional


def quadrado(numero):  # Passagem obrigatória
    return numero ** 2


print(quadrado(3))  # ok
# print(quadrado())  # Veja que aqui a passagem de parâmetro é obrigatória


def exponencial(numero=4, potencia=2):  # veja que agora não precisamos de nenhume argumento, teremos 4 ** 2
    return numero ** potencia


"""
Na definição de um método, dizer que um parâmetro é igual a algo (2 por exemplo), faz ele ser opcional. Veja que essa
sacada é muito simples, mas muito importante
"""


print(exponencial(2, 3))  # ok
print(exponencial(2))  # ok
print(exponencial())  # ok

"""
A ordem dos argumentos importa
Obs.: Em funções Python, os parâmetros com valores default, DEVEM sempre estar ao final da declaração, ou seja:
"""


# def quadrado(num=2, potencia):
#    return num ** potencia
# print(2) Poderíamos até pensar que esse 2 vai para a potência, mas não vai, pois o parâmetro default deve estar no fim

# Exemplo mais completo:

print('-----')


def mostra_informacao(nome='Francisco', instrutor=False):  # dois parâmetros não obrigatórios
    if nome == 'Francisco' and instrutor:  # e instrutor for True
        return 'Bem-vindo instrutor Francisco'
    elif nome == 'Francisco':
        return 'Eu pensei que você era instrutor'
    return f'Olá {nome}'


print(mostra_informacao())
print(mostra_informacao(instrutor=True))  # Preciso escrever o nome "instrutor". Caso não, será atribuido ao "nome"
print(mostra_informacao('Ana'))  # Podemos fazer de dois jeitos
print(mostra_informacao(nome='Ana'))  # Podemos fazer de dois jeitos
print(mostra_informacao(True))  # Veja que essa variável agora atribuída ao nome

print('-----')


def soma(num1, num2):
    return num1 + num2


def mat(num1, num2, fun=soma):  # não é comum em outras linguagens
    return fun(num1, num2)  # aqui já estamos usando a função soma como paradigma


def subracao(num1, num2):
    return num1 - num2


print(mat(2, 3))  # veja, que aqui já estamos usando a função soma.
print(mat(2, 3, subracao))  # Aqui estamos usando a função subração. Além disso, veja que a função subtração está sem
# parênteses.


# Exemplos de escopo de variável. Variáveis Globais e Variáveis Locais. Evita problemas
print('-----')

instrutor = 'Petróleo'  # Exemplo de variável global. Pois está fora da função


def diz_oi():
    instrutor = 'Engenharia'  # dentro da função
    """
    Exemplo de variável local, veja que ela se sobressai em relação global, veja que ela também está marcada
    Essa variável local só existe dentro desse bloco, nem adianta chamar ela dentro de um print fora do bloco que 
    ela não vai existir
    """

    return f'oi {instrutor}'  # Esse return é muito legal


print(diz_oi())
# A dica é, evitar variável global, usar apenas se tiver confiança para usar.
# Outro exemplo, para trabalhar com variáveis globais


print('-----')
total = 0


def incremento():
    global total  # Avisanso ao Python que a variável é a global que está lá fora. Uma forma de inicializar a variável
    total = total + 1  # Se a inicialização gera um UnbooundLocalError.
    return total

# A declaração global se parece com o VBA do excel


print(incremento())
print(incremento())
print(incremento())  # Legal, aqui fica tipo um for

"""
Podemos ter funções que podem ser declaradas dentro de funçoes, além de ter uma forma especial de escopo de variável
Um jeito diferente de usar uma variável fora do escopo

Não é comum, mas é importante saber
"""
print('-----')


def fora():
    contador = 0

    def dentro():
        nonlocal contador  # Veja que "contador" não é local, não é global, É A VARIÁVEL QUE ESTÁ NA FUNÇÃO ANTERIOR
        # significa que está na função anterior
        contador = contador + 1
        return contador
    return dentro()


print(fora())
print(fora())
print(fora())

#  print(dentro()) # veja que só existe no escopo da função fora, a função dentro não roda sozinha. Gera NameError

------------------------------------------------------------------------------------------------------------------

"""
DOCSTRINGS:

Documentando funções com Docstring: São as aspas para comentários.
É importante documentar apenas o que é essencial

- Faça: print(help(print)) no terminal do Python, lá existem documentações docstring
help() or .__doc__
A aprência do help é melhor!
"""


# Exemplos:
def diz_oi():
    """A documentação de uma função simples"""
    return 'Olá!'

# No terminal, faça: from docstring import diz_oi
# help(diz_oi) or print(diz_oi.__doc__)


# o Próprio Python cria documentação automática
def exponencial(numero, potencia=2):
    """
    A função retorna o quadrado de outro, ou a qualquer potência informada
    :param numero:  Base, obrigatório
    :param potencia: Expoente, opicinal
    :return: Rertono a potênica de um número
    """
    return numero ** potencia
# Por algum motivo não estou conseguindo importar essa função no terminal

------------------------------------------------------------------------------------------------------------------

"""
ARGS:

Entendendo o *args: Um parâmetro especial de funções
*args: parâmetro de entrada, como qualquer outro. Significa que você poderá chamá-lo de qualquer nome, desde de que
comece com asterisco

O que é o *args?
- é utilizado em uma função e coloca os valores extras informados como entrada em uma tupla. Ou seja, imutáveis! já
que é uma tupla ou vai será transformada em tupla.
- o argumento nõa é obrigatório
- naturalmente, o * desempacota
Observação pessoal. Ele transforma os dados em tuplas, mas gera erro ao transformar tupla em tupla.
"""
# Exemplo 1 - não trabalha além dos 3 argumentos, mesmo com argumento padrão, e teríamos que trabalhar com o return...


def soma_todos(num1, num2, num3):
    return num1+num2+num3


print(soma_todos(1, 2, 3))  # ok
# print(soma_todos(1, 2))  # Ok, se existir parâmetro padrão
# print(soma_todos(1, 2, 3, 6))  # TypeError, mesmo se existir parâmetro padrão


print('-----')
# Exemplo 2 - Entendendo o *args


def soma_todos_novamente(*args):  # Com asterisco
    print(args)  # sem asterisco


soma_todos_novamente()
soma_todos_novamente(1)
soma_todos_novamente(1, 2)
soma_todos_novamente(1, 2, 3)
print('-----')


# Refatorando


def soma_agora(*args):
    total = 0
    for numero in args:
        total = total + numero
    return total


print(soma_agora())
print(soma_agora(1, 2))
print(soma_agora(1, 2, 3))
print(soma_agora(1, 2, 3, 4))


# or
print('-----')


def depois_soma(*args):
    return sum(args)


print(depois_soma())
print(depois_soma(1, 2))
print(depois_soma(1, 2, 3))
print(depois_soma(1, 2, 3, 4))


# Outro exemplo
def verifica_inf(*args):
    if 'Francisco' in args and 'Araújo' in args:
        return 'Bem vindo Francisco'
    return 'Não tenho certeza de quem você é!'


print(verifica_inf())
print(verifica_inf(1, True, 'Francisco', 'Araújo'))
print(verifica_inf(1, 'Araújo', 2.71))


# Como resolver esse problema ao somar elementos de uma lista em um args?
print('-----')


def somando(*args):
    return sum(args)


# Desempacotador para resolver o problema do TypeErro abaixo. Vamos fazer automaticamente.
"""
Modo antigo: num1, num2, num3, num4 = numeros / modo moderno: *numeros
O asterisco indica que estamos passando uma coleção e que precisa ser desempacotado
Até o momento, podemos desempacotar conjunto, lista e até a própria tupla. Mas ainda não podemos desempacotar um dict.
"""
numeros = (1, 2, 2,)
print(somando(*numeros))  # sem o asterisoco gera um TypeError

# Meu exemplo :-)


def mensagem(*args, nome='Francisco', sobrenome='Araújo'):
    return f'Olá {nome} {sobrenome} Seu número da sorte é {sum(args)}'


num = [1, 2, 3]
print(mensagem(*num, nome='Larissa'))

------------------------------------------------------------------------------------------------------------------

"""
KWARGS:

-Entendendo o **kwargs: É apenas uma convenção. Vai funcionar desde que tenha "**". Usado para parâmetros extras
-É apenas uma parâmentro
-Exige que utilizemos parâmetros nomeados. Esses parâmetros são transformados em um dicionário
-Tanto o *args quando o **kwargs não são obrigatórios
-naturalmente, o ** desempacota
-ao usar dicionários em uma função, cuidado! os nomes da chave em um dicionário devem ser os mesmos dos parâmetros
da função

"""
# Exemplo 1:


def cores_favoritas(**kwargs):
    for pessoa, cor in kwargs.items():
        print(f'A cor favorita de {pessoa.title()} é {cor}!')


cores_favoritas(eu='Azul', ela='preto', nos='azul escuro')  # Vai criar o dicionário
cores_favoritas()  # Não gera erro
cores_favoritas(Francisco='Araújo')

# Exemplo 3
print('-----')


def cumprimento_especial(**kwargs):
    if 'Francisco' in kwargs and kwargs['Francisco'] == 'Araújo':  # se a chave estiver no dicionário e valor for Ara...
        return 'Você recebeu um comprimento direto de Francisco Araújo!'
    elif 'Francisco' in kwargs:  # Se a chave estiver no dicionário
        return f"{kwargs['Francisco']}, é o sobrenome do Fracisco"
    return 'Não faço ideia de quem seja você!'


print(cumprimento_especial())
print(cumprimento_especial(Francisco='Araújo'))
print(cumprimento_especial(Francisco='Almeida'))
print(cumprimento_especial(Francisco='Silva'))

"""
Em suma, nas nossas funções podemos ter (nesta ordem - se for usar todos):
- Parâmetros obrigatórios
- *args
- Parâmetros default (não obrigatórios)
- **kwargs
"""
# Vejo o exemplo abaixo. Podemos ter no mesmo argumento, tipos repetidos de parâmetro.
print('-----')


def minha_func(nome, idade, *args, solteiro=False, **kwargs):
    print(f'{nome} tem {idade} anos!')
    print(sum(args))
    if solteiro:
        print('Solteiro')
    else:
        print('Pegando')
    print(kwargs)


numeroo = [2, 3, 4]
print(minha_func('Francisco', 25, *numeroo, True, Arg='dicionário'))
print('-----')
print(minha_func('Francisco', 25, curso='Engenha', espec='Petróleo'))  # Os dois últimos vão para **kwargs


# Desempacotar com o **kwargs
print('-----')


def mostra_nomes(**kwargs):
    return f"{kwargs['nome']} {kwargs['sobrenome']}"


nomes = {'nome': 'Francisco', 'sobrenome': 'Araújo'}  # É aquela outra forma de criar dicionário

# print(mostra_nomes(nomes))  # Gera erro, pois não tem como desempacotar assim
print(mostra_nomes(nome='Eu', sobrenome='Araújo'))  # ok
print(mostra_nomes(**nomes))  # Pythônico

------------------------------------------------------------------------------------------------------------------

"""
Exercícios da Seção 8
"""
import math

# 1


def func(numero):
    return numero * 2


print(func(10))
print('-----')

# 2


def horario(dia, mes, ano):
    meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez']
    return f'{dia} de {meses[mes-1]} de {ano}'


print(horario(1, 12, 2022))


# 3
print('-----')


def avalia(numero):
    if numero < 0:
        return -1
    elif numero == 0:
        return 0
    return 1


print(avalia(0))


# 4
print('-----')


def verifica(numero):
    if numero < 0:
        return f'{numero} é um número negativo, não poderá ser quadrado perfeito!'
    elif numero == 0:
        return f'{numero} não é um quadrado perfeito!'
    else:
        if numero**(1/2) == int(numero**(1/2)):
            return f'{numero} é um quadrado perfeito!'
        return f'{numero} não é um quadrado perfeito!'


print(verifica(9))


# 5
print('-----')


def volume(raio):
    return f'Volume da esfera: {(4/3)*math.pi*raio**2} u.v'


print(volume(2))


# 8
print('----')


def raiz(ca, co):
    return f'Valor da hipotenusa = {math.sqrt(ca**2+co**2)}'


print(raiz(2, 2))


# 10
print('-----')


def tipo(a, b):
    tip = [a, b]
    return f'O maior: {max(tip)}'


print(tipo(5, 4))


# 11
print('-----')


pesos = [5, 3, 2]
somando = 0


def analisa(a, b, c, *args):
    global pesos
    global somando
    listanota = [a, b, c]
    if args[0] == 'A' or args[0] == 'a':  # [0]
        soma = a+b+c
        return f'A média aritmética: {soma/(len(pesos))}'
    elif args[0] == 'P' or args[0] == 'p':
        for numero in range(0, len(pesos)):
            somando += pesos[numero] * listanota[numero]
    return f'A média ponderada: {somando/sum(pesos)}'


print(analisa(1, 2, 3, 'a'))
print(analisa(1, 2, 3, 'P'))


# 13
print('-----')


def realiza(a, b, *args):
    if args[0] == '+':
        return f'Soma: {a+b}'
    elif args[0] == '-':
        return f'Subtração: {a-b}'
    elif args[0] == '/':
        return f'Divisão: {a/b}'
    elif args[0] == '*':
        return f'Multiplicação: {a*b}'
    return f"Escolha '+' para adição, '-' para subtração, '/' para divisão ou '*' para multiplicação"


print(realiza(1, 2, '+'))
print(realiza(1, 2, '-'))
print(realiza(1, 2, '/'))
print(realiza(1, 2, '*'))


# 22
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
LIST COMPREHENSION PARTE 1:

COMPREHENSION: poderoso. Apenas na linguagem python

Parte 1
- Utilizando o List Comprehension, podemos gerar novas listas com dados processados a partir de outro iterável.

# Sintaxe
[dado for dado in iterável] # Para cada dado na coleção, precesse o dado. Veja que lemos de trás para frente
dado: variável
iterável: coleção
"""
# Exemplo
numeros = [10, 20, 30, 40, 50, 60]
res = [dado/10 for dado in numeros]
print(f'A funcionalidade da List Comprehension: {res}')

"""
Ou seja:
Parte 1 - for dado in numeros; Para cada número na lista
Parte 2 - dado/10; O processamento que vai modificar a lista
"""

# Exemplo:


def uma_funcao(numer):
    return numer*numer


print(uma_funcao(2))
print('-----')


listao = [1, 2]
resp = [uma_funcao(dado) for dado in listao]
print(f' A função aplicada numa lista qualquer trabalhando com o list comprehension: {resp}') # Isso aqui é muito
# interessante

# Loop v List Comprehension
print('-----')

# loop - Para quem conhece o Python
umalista = [10, 20, 30, 40]
umaListaVazia = []

for N in umalista:
    num_dobrado = N*2
    umaListaVazia.append(num_dobrado)

print(f' A lista original: {umalista}')
print(f' A lista dorbrada: {umaListaVazia}')
print('-----')

# List Comphension - Para quem conhece o Python Avançado
print(f' A lista dobrada com List Comprehension: {[numero*2 for numero in umalista]}')
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
LIST COMPREHENSION PARTE 2:

Podemos adicionar estrutrua condicionais lógicas às nossas List Comprehension

# Sintaxe
[dado for dado in coleção condição]
"""

#  Exemplo 1: verifica os pares
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(f'Os pares: {[dado for dado in numeros if dado % 2 == 0]}')

"""
Ou seja, estamos dizendo que:
Pegamos o dado, para cada dado na coleção se o resto da divisão desse dado por 2 for 0 (condição de paridade).
"""

#  Exemplo 2: verifica os ímpares
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(f'Os ímpares: {[dado for dado in numeros if dado % 2 != 0]}')
print('------')


# Refatorado:
"""
Quando o número é par, o módulo de 2 é zero. Zero em Python é False. A Condiçao not
gera False = True. Vai salvar os True, que são os pares (False).
Estamos fazendo uma negação.
"""
print(f'Os pares: {[nume for nume in numeros if not nume % 2]}')

# Qualquer número ímpar módulo de 2 é 1, e 1 em Python é True. Vai salvar os True. Nem precisa de negação.
print(f'Os pares: {[nume for nume in numeros if nume % 2]}')


# Exemplo 3: condição no início
print(f'Modificando: {[numero**numero if numero % 2 == 0 else numero/numero for numero in numeros]}')
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
LISTAS ANINHADAS:

Algumas linguagens de programação possuem uma estrutura de dados chamadas de arrays:
    - Unidimensionais (arrays/vetores)
    - Multidimensionais (matrizes)

Em Python temos as listas

numeros = [1, 'b', 3.14, 4, True, 6]
"""

listas = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # Matriz 3x3
print(listas)
print(type(listas))

# Como acessar os dados?
print(listas[0][2])  # Acessando a linha 1, coluna 3 da matriz
print(listas[2][1])  # Acessando a linha 3, coluna 2 da matriz
print(listas[2][-2])  # Acessando a linha 3, coluna 2 da matriz


# Iterando com loops em uma lista aninhada. Vamos precisar de dois loops.
print('-----')

for lista in listas:
    for num in lista:
        print(f'O número com o for: {num}')


# Muito mais fácil do que no matlab. Isso é alegria
# Como usar list comprehension nesse caso?
print('-----')

# Primeiro [[]for lista in listas]
# Segundo [[for valor in lista]for lista in listas]
# Terceiro [[print(valor) for valor in lista] for lista in listas]
[[print(f'O valor com list comprehension: {valor}') for valor in lista] for lista in listas]
print('-----')

# gerando uma matriz 3x3

print(f'A matriz: {[[numero for numero in range(1, 4) ]for valor in range(1, 4)]}')
print('-----')
""" 
Primeiro preencheu colunas com o "valor", depois preencheu as linhas com o "numero".
"""


# Jogo da velha. Vamos usar a estrutura condicional
a = [['x' if numero % 2 == 0 else '0' for numero in range(1, 4)]for valor in range(1, 4)]
print(f'O jogo da velha: {a}')
print('-----')

# Gerando valores iniciais
print(f"Com valores inciais: {[['*' for val in range(1, 4)] for nu in range(1, 4)]}")

------------------------------------------------------------------------------------------------------------------

"""
DICTIONARY COMPREHENSION:

Pense:
se quisermos criar:
lista = [1, 2, 3, 4]
tupla = (1, 3, 5, 5) ou 1, 3, 5, 5,
conjunto = {1, 3, 5, 5}
dicionário {'a': 1, 'b': 2}

# sintaxe
{chave: valor for valor in interável}: dictionary comprehension
[valor for valor in iterável]: list comprehension
"""

# exemplo
numeros = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e':5}
quadrado = {chave: valor ** 2 for chave, valor in numeros.items()}
"""
 Ou seja, vamos elevar todos os valores ao quadrado. Mas não modificamos a chave
 """

print(f'O dicionário ao quadrado: {quadrado}')
print('-----')


"""
Imagine que você tem uma lista de números, e deseja elevar esses números ao quadrado e colocar em um dicionário:
"""

numeroListas = [1, 3, 5, 6]
# numeroListas = {1, 3, 5, 6}  # Poderíamos também usar esse set
quadrad = {valor: valor**3 for valor in numeroListas}  # lembrar que dicionário não aceita chave repetida.
print(f'O cubo dos valores da lista em um dicionário: {quadrad}')
print('-----')

# Criando chaves e valores a partir de uma string e uma lista

chavesss = 'abcde'
valores = [1, 2, 3, 4, 5]

mistura = {chavesss[i]: valores[i] for i in range(0, len(valores))}
print(f'Juntando as chaves: {mistura}')
print('-----')

# Exemplo com estrutura condicional
numpe = [1, 2, 3, 4, 5, 6]
res = {num: ('par' if num % 2 == 0 else 'ímpar') for num in numpe}
print(f'O dicionário com as específicações: {res}')
------------------------------------------------------------------------------------------------------------------

"""
SET COMPREHENSION:

Lembrar que set não guarda ordenação e não aceita repetição de valores.
"""
# exemplo

numeros = {num for num in range(1, 7)}
print(numeros)
print('----')

# outro
res = {num**3 for num in range(10)}
print(res)
print('-----')

# gerando um dicionário
resp = {num: num**3 for num in range(10)}
print(resp)
print('-----')

# exemplo com string
letras = {letra for letra in 'Francisco Araújo'}
print(f'O set de letras: {letras}')

------------------------------------------------------------------------------------------------------------------

"""
LAMBDAS:

Utilizando lambdas:
    - São funções sem nome, anônima
    - Palavra reservada: lambda
    - Podemos ter múlitplas entradas

Obs.: Só aceita a quantidade de argumentos esperados
"""


def fucao(x):
    return 3 * x + 1


print(f'O retorno: {fucao(2)}')
print('-----')

# Expressão lambda
lambda x: 3 * x + 1

"""
x-> Parâmetros de entrada
Como não tem nome, vamos direto para o retorno: 3 * x + 1
"""

# Como utilizar a expressão lambda? Podmeos dar um nome a ela
calc = lambda x: 3 * x + 1  # Não é a forma correta de utilização dessas expressões.


print(f'O valor do cálculo: {calc}')
print('-----')

# Imagine um formulário, com nome e sebrenome em campos diferentes, com múltiplas entradas. Mas precisamos do nome
# e sobrenome.

"""
Entradas: logo após a palavra reservada "lambda" e antes dos dois pontos.
nome e sobrenome: são duas entradas

strip(): nome = ' Francisco '; nome.strip() = 'Francisco'. Ou seja, remove espaços no início e no fim.
title(): Transforma a primeira letra em caixa alta
"""

nome_completo = lambda nome, sobrenome: nome.strip().title() + ' ' + sobrenome.strip().title()

print(nome_completo(' francisco', ' araújo   '))
print('-----')


# lambda sem entrada
like = lambda: 'Como não gostar do Python?'
love = lambda x: 3 * x
avenue = lambda x, y: x * y

print(like())
print(love(4))
print(avenue(1, 4))
print('-----')


# lista de autores

autores = ['Francisco Araújo', 'Senhora lendy', 'Senhora alquimista', 'Os três', 'O grande êxodo', 'L. G. Almeida']
print(autores)
print('-----')

# E se precisar ordenar pelo sobrenome? Usando o lambda de forma Pythônica
autores.sort(key=lambda sobrenome: sobrenome.split(' ')[-1].lower())  # [-1] pega o útlimo elemento da lista, RODA
# sort(). faz a ordenação
print(autores)
print('-----')

# split(): gera lista a cada espaço
# lower(): transforma tudo em minúsculo

"""
Agora, uma aplicação muito interessante.
Vamos criar uma função quadrática, recebendo as constantes e o valor da variável x.
"""


def geradora_quadratica(a, b, c):
    return lambda x: a*x**2+b*x+c


Teste = geradora_quadratica(2, 4, 4)
print(Teste(2))
print(Teste(-1))
print(Teste(25))
print('-----')

# ou

print(f'O valor da função quadrática: {geradora_quadratica(2, 4, 4)(2)}')
print(f'O valor da função quadrática: {geradora_quadratica(2, 4, 4)(-1)}')
print(f'O valor da função quadrática: {geradora_quadratica(2, 4, 4)(25)}')
print('-----')

"""
E onde aplicamos as expressões lambdas?
Geralmente: 
    -filtragem
    -ordenação de dados
"""

------------------------------------------------------------------------------------------------------------------

"""
MAP:

A função do map recebe um parâmetro
Map: Fazemos mapeamento de valores para função.
Não confundir esse Map com o Mapa estudado em coleções
Map: recebe dois parâmetros. Primeiro; a função. Segundo; um iterável
Retorna um map object. Mas posso converter
Só podemos usar uma única vez
A função do Map recebe apenas um parâmetro. Isto é importante.
"""

import math


def aras(r):
    """
    :param r: raio do círculo
    :return: área
    """
    return math.pi*r**2


print(f'A áreia do círculo: {aras(2)} u.a')
print(f'A áreia do círculo: {aras(3.14)} u.a')
print('-----')

# Imagine agora. Uma lista contendo vários raios:
raios = [2, 3, 5, 20]

"""
Primeiro: Calculando todos os raios 
"""
raio = []
for i in raios:
    raio.append(aras(i))


print(f'Todos os raios a partir da lista de raios: {raio}')
print('-----')

"""
Segunda forma. Usando o Map. Essa função vai usar cada função do iterável e aplicar na função. Por isso recebe 
dois parâmentros
"""

areeas = map(aras, raios)
print(areeas)
print(type(areeas))
print(f'Valores transformados em lista: {list(areeas)}')  # muito mais prático
print('-----')

# A grande sacada, é que geralmente não criamos uma função para isso. Usamos as expressções lambdas direto no map.
# Vamos refatorar nosso problemas:
print(f'A área da nossa função refatorada: {list(map(lambda r: math.pi*r**2, raios))}')
print('-----')

"""
NOTA IMPORTANTE: 
Após utilizar a função map(), depois da primeira utilização do resultado nossos valores são zerados

Para fixar: Map precisa de uma função ou um iterável. Essa função pode ser anônima or não.
"""

# Exemplo com cidade e temperatura em graus celcius

cidades = [('Berlim', 29), ('Cairo', 36), ('Buenos Aires', 19), ('Los Angeles', 26), ('Tokio', 27), ('Nova York', 28),
           ('Londres', 22)]

# como podemos passar para gruas fahrenheit?
"""
dado: lista de cidades, nesse caso
f = 9/5 * c + 32
"""

c_para_f = lambda dado: (dado[0], (9/5) * dado[1] + 32)

print(f'Cidades com as temperaturas convertidas:\n {list(map(c_para_f, cidades))}')

# Esse exemplo foi muito bom.

------------------------------------------------------------------------------------------------------------------

"""
FILTER:

A função do filter recebe um parâmetro
Lambda + filter parece uma ótima combinação
O objetivo é conhecer o Python e pensar fora da caixa.
Uma vez aplicado Map e Filter, mostra-se que você conhece o Python
filter: utizado para filtrar dados de uma determinada coleção
Assim como a função Map, a filter recebe dois parâmetros (função, iterável)
Assim como o Map, aqui, usamos os dados apenas uma vez.
Retornamos um objeto
Usado para remoção de dados faltantes: fundamental para quem quer trabalhar com ciência de dados, para não distorcer
o resultado final

Diferença clara entre Map e Filter
Map: Rertonar valores. Recebe uma função e um iterável e retorna um objeto mapeando a função para cada elemento
do iterável
Filter: Retorna True ou False (booleano) para ser usado como filtro. Recebe uma função e um iterável e retorna
um objeto filtrando apenas um elemento de acordo com a função.
"""
# Biblioteca para trabalhar com estatística
import statistics

valores = 1, 2, 3, 4, 5, 6, 7, 8, 9,
print(type(valores))
media = (sum(valores))/len(valores)
print(f'A média: {media}')
print('-----')

# Dados coletados de algum sensor
dados = [1.3, 3.7, 0.8, 4.1, 4.3, -0.1]

# função mean da biblioteca statistics
med = statistics.mean(dados)

print(f'A média: {med}')
res = filter(lambda x: x > med, dados)  # O 'x' representa cada dado de uma função
print(type(res))
"""
Nessa análise do filter, retornamos True or False
"""
print(list(res))
print('-----')
print(f'Não imprime novamente: {list(res)}')
print('-----')

# Dados faltantes

paises = ['', 'Argentina', '', 'Brasil', 'Chile', '', 'Colombia', '', 'Equador', '', '', 'Venezuela']
print(f'Sem o filter:\n {paises}')
print(f'Com o filter:\n {list(filter(None, paises))}')
"""
O None vai remover os espaços em branco e usar
os não vazios. Recomendado.
"""
print(f'Com lamba:\n {list(filter(lambda pais: len(pais) > 0, paises))}')  # or pais != '', paises
print('-----')


# Exemplo mais complexo. Temos uma lista cujos elementos são dicionários
usuarios = [
    {"username": "Samuel", "tweets": ["Eu adoro bolos", "Eu adoro pizzas"]},
    {"username": "Carla", "tweets": ["Eu amo gatos"]},
    {"username": "Larissa", "tweets": []},
    {"username": "Pedro", "tweets": []},
    {"username": "Eliza", "tweets": ["Eu gosto de cachorros", "Vou sair hoje"]},
    {"username": "Anna", "tweets": []}
]


print(f'Os usuários do twitter:\n {usuarios}')
print('-----')
# Filtrar os usuários inativos no twitter. Aqueles sem tweets
inativos = list(filter(lambda u: len(u['tweets']) == 0, usuarios))
"""
Ou seja, para cada elemento de "usuários" passamos para a variável "u", e fazemos a seleção com as propriedades dos
dicionários
"""
print(f'Usuários inativos no twitter:\n {inativos}')
print('-----')
print(f"Usuários ativos no twitter:\n {list(filter(lambda u: len(u['tweets']) != 0, usuarios))}")


# Refatorando os usuários inativos.
"""
No terminal: 
usuarios = {"username": "Samuel", "tweets": ["Eu adoro bolos", "Eu adoro pizzas"]}
usuarios
not usuarios['tweets'] -> gera False, já que possui tweets. Se possui tweets gera True, mas not gera a negação.
Portanto, o vazio significa False e não vazio significa True
"""

# Forma 2:
inativos2 = list(filter(lambda usuario: not usuario['tweets'], usuarios))  # Modo avançado
"""
Ou seja, uma lista vazia transformada em booleano gera False: usuario['tweets']
"""
print(f'Os novos inativos refatorados:\n {inativos2}')
print('-----')


# Combinando map() e filter()
"""
Tarefa: criar uma lista contendo 'Sua instrutura é' + nome, desde que cada nome tenha menos que 5 caracteres.
"""

nomes = ['Carla', 'Roberto', 'Larissa', 'Letícia', 'Bia', 'Lois']
lista = list(map(lambda nome: f'Sua instrutora é {nome}', filter(lambda nome: len(nome) < 5, nomes)))
"""
Observe que filter() está dentro de map() como segundo argumento já filtrado, já que o map() recebe dois parâmentros
"""
print(f'A classificação das instrutores:\n {lista}')

------------------------------------------------------------------------------------------------------------------

"""
REDUCE:

É viável para um teste de programação, pois demonstra conhecimeno avançado.
A função do reduce recebe dois parâmetros
Essa função recebe dois parâmetros: a função e o iterável
Um pouco mais confuso.
reduce: a partir do Python 3.0 a função reduce() não é mais uma função integrada (built-in). Agora temos que
importar e utilizar a partir do módulo 'functools'

Guido van Rossum: Utilize a função reduce() se você realmente precisa dela. Em todo caso, 99% das vezes um loop for
é mais legível.

Imagine a situação:
dados = [a1, a2, a3, a4, ..., an]

Precisa de uma função que recebe dois parâmetros:
    def func(x, y)
        return x*y

reduce(func, dados)

Funcionamento do reduce:
Passo 1: res1 = f(a1, a2) # Aplica a função no dois primeiros elementos da coleção e guarda o resultado
Passo 2: res2 = f(res1, a3) # Aplica a função passando o resultado do passo 1 mais o terceiro elemento e guarda o resul.

E assim por diante até obter o resultado final.


Forma alternativa para o reduce:
funcao(funcao(funcao(a1, a2), a3), a4), ...), an)
"""
# Na prática
# aplicando reduce para multiplicar todos os valores de uma lista
from functools import reduce

dados = [2, 3, 4, 7, 11, 13, 19, 23, 29]

# Vamos usar a função lambda recebendo dois parâmetros

res = reduce(lambda x, y: x * y, dados)
print(f'O resultado com o reduce:\n {res}')

# Fazendo a mesma operação com laço for
res = 1
for n in dados:
    res = res * n

print(f'O resultado com o for:\n {res}')

------------------------------------------------------------------------------------------------------------------

"""
ANY E ALL:

algum e todo
Any e all
All(): retorna True (booleano) se todos os elementos do iterável são verdadeiros ou ainda se o iterável estiver vazio.
Uma função booleana

any(): retorna True se qualquer elemento do iterável for verdadeiro. Se o iterável estiver vazio, retorna False
"""

# Exemplo all()
print(all([0, 1, 2, 3, 4]))  # todos os valores são True, menos o 0. False
print(all([1, 2, 3, 4]))  # True
print(all([]))  # True
print(all('Francisco Araújo'))  # True
print('-----')


# Vamos fazer uma busca com list comprehension + all(). Bom para se fazer uma checagem
nomes = ['Carina', 'Carla', 'Clara', 'Camilha', 'Cassiano', 'Cristina']
print(all([nome[0] == 'C' for nome in nomes]))
print('-----')

# Um iterável vazio convertido em booleano é False, mas o all() entende como True. Sempre vai dar True aqui.
print(all([letra for letra in 'eio' if letra in 'aeiou']))
print('-----')

# outro caso, e for par vai da True, se for vazio vai dar True
print(all([num for num in [4, 2, 10, 6, 8] if num % 1 == 0]))
print('-----')

# Exemplo com any()
print(any([0, 1, 2, 3, 4]))  # se tiver apenas um verdadeiro, retorna verdadeiro.
print(any([]))  # False

nomes = ['Carina', 'Carla', 'Clara', 'Camilha', 'Cassiano', 'Cristina', 'Francisco']
print(any([nome[0] == 'C' for nome in nomes]))  # True
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
GENERATORS EXPRESSION:

Possui muita performance, confirme com os resultados a baixo.
Generators: Vai gerar um objeto em memória, ou seja, posso mudar o estilo do dado
    - Podemos usar os dados apenas uma vez, assim como map, filter...
    - Possui muito mais performance
Já vimos;
    - list comprehensionc, já gera lista em memória
    - dictionary comprehension, já gera dicionário em memória
    - set comprehension, já gera conjunto em memória

Não vimos;
    - tuple comprehension, pois elas sãos os chamados  GENERATORS

Na aula passado foi feito:
nomes = ['Carina', 'Carla', 'Clara', 'Camilha', 'Cassiano', 'Cristina', 'Francisco']
print(any([nome[0] == 'C' for nome in nomes]))  # True

Obs.: Poderíamos fazer usando generators.
Portanto, é recomendado usar o generators na maioria dos casos, a não ser que queiramos um conjuta, um dicionáiro ou
uma lista logo de cara.
"""
# Qual a utilidade de getsizeof()? - Retorna a quantidade de bytes em memória do elemento passado como parâmetro.
from sys import getsizeof
print(getsizeof('Francisco Araújo'))
print(getsizeof(9))
print(getsizeof(96356525653256))
print(getsizeof(True))
print('-----')

# lista de números usando o list comprehension
list_comp = getsizeof([x * 10 for x in range(1000)])
print(f'Bytes em list comprehension: {list_comp}')
print('-----')
# lista de números usando o set comprehension
set_comp = getsizeof({x * 10 for x in range(1000)})
print(f'Bytes em set comprehension: {set_comp}')
print('-----')
# lista de números usando o dictionary comprehension
dic_comp = getsizeof({x: x * 10 for x in range(1000)})
print(f'Bytes em dic comprehension: {dic_comp}')
print('------')
# lista de números usando o generators
gen = getsizeof(x * 10 for x in range(1000))
print(f'Veja como temos menos bytes em Generator Expression: {gen}')
print('-----')

# Usando generators
nomes = ['Carina', 'Carla', 'Clara', 'Camilha', 'Cassiano', 'Cristina', 'Francisco']
print(any((nome[0] == 'C' for nome in nomes)))  # Veja que agora é um tuple comprehension (generators).
# Vai gerar performance
print('-----')

"""
Por que o generator usa tão pouco bytes em memória?
Porque ele ainda não gerou nada, só deixou tudo preparado, e quando for usar vai gerar em memória e apagar em memória, 
diferente do lis comprehension
"""

gen = (x * 10 for x in range(1000))
print(gen)
print(type(gen))

for num in gen:
    print(num)




------------------------------------------------------------------------------------------------------------------

"""
SORTED:

ELE SEMPRE IRÁ RETORNAR UMA LISTA (por padrão, mas posso mudar) COM OS ELEMENTOS DO ITERÁVEL
Sorted: Serve para ordenar, mas funciona além das listas, inclusive, para elas, também. Além disso, ele cria uma nova
lista ordenada, diferente do sort() - que ordena a própria lista
Obs.: Nâo confundir com a função sort() que já estudamos. Além disso, lembrar que sort() funciona APENAS em listas:
lembrar como usar:
dado_lista = [3, 2, 1]
dado_lista.sort()
>> [1, 2, 3]
"""
numeros = [6, 1, 8, 2]
print(numeros)  # Sem ordenação
print(sorted(numeros))  # Com ordenação e com uma nova lista
print(numeros)  # Sem ordenação, mesma distribuição dos dados originais
print('-----')
numeros1 = 6, 1, 8, 2,
print(sorted(numeros1))  # Retorna essa tupla em formato de lista ordenada

# Adicionando parâmetros ao sorted()
print(sorted(numeros1, reverse=True))  # Ordena e inverte a lista

# Convertendo o serted()
print(tuple(sorted(numeros1, reverse=True)))
print('-----')
# Exemplo mais complexo com o sorted()
usuarios = [
    {"username": "Samuel", "tweets": ["Eu adoro bolos", "Eu adoro pizzas"]},
    {"username": "Carla", "tweets": ["Eu amo gatos"]},
    {"username": "Larissa", "tweets": []},
    {"username": "Pedro", "tweets": []},
    {"username": "Eliza", "tweets": ["Eu gosto de cachorros", "Vou sair hoje"]},
    {"username": "Anna", "tweets": []}
]


print(f'Os usuários do twitter:\n {usuarios}')
print('-----')
# print(sorted(usuarios))  # não vai funcionar, ele não itera em dicionário assim
print(sorted(usuarios, key=lambda usuario: usuario["username"]))  # Na chave, podemos passar até uma função para odern.
print('-----')
"""
Estamos ordenando pelo nome de usuário, mas podemos pelo tweets
"""

# Ordenando pela quantidade de tweets do usuário (do maior para o menor)
print(sorted(usuarios, key=lambda usuario: len(usuario['tweets']), reverse=True))
print('-----')

# Imagine a lista de músicas, com seus respectivos títulos e quantidade de vezez que ela tocou.
musicas = [
    {"título": 'Rap', "tocou": 3},
    {"título": 'MPB', "tocou": 32},
    {"título": 'Sertanejo', "tocou": 21},
    {"título": 'Rock', "tocou": 80},
    {"título": 'Serenata', "tocou": 17}]

# Ordena da menos tocada para a mais tocada
print(sorted(musicas, key=lambda mus: mus['tocou']))

# Ordena da mais tocada para a menos tocada
print(sorted(musicas, key=lambda mus: mus['tocou'], reverse=True))

------------------------------------------------------------------------------------------------------------------

"""
MIN E MAX:

max e min: retorna o maior/menor valor em um iterável ou o maior/menor de dois ou mais elementos.
funciona para:
- lista
- tupla
- set
- dicionário. Esse precisa de cuidado
"""
"""
# Exemplos
lista = [1, 8, 4, 99, 34, 129]
print(max(lista))
print('-----')

dicionario = {'a': 1, 'b': 8, 'c': 4, 'd': 99, 'e': 34, 'f': 129}
print(max(dicionario))  # Vai retorna "f", a maior chave
print(max(dicionario.values()))  # Vai retorna 129, o maior valor
"""

# Olha como é fácil no Python, nem precisamos de estrutura condicional para obter um dado
# Construir um código que recebe dois valores do usuário e retorna o maior

# valor1 = int(input('Digite o primeiro valor: '))
# valor2 = int(input('Digite o segundo valor: '))
# print(f'O maior valor: {max(valor1, valor2)}')

# or
print(max('a', 'b', 'g'))  # retorna o maior em relação a posição no alfabeto
print(max('a', 'ab', 'abc', 'abcd'))  # retorna o maior em relação a quantidade de elementos
print(max(1.3344, 1.3343))
print('-----')

# Outros exemplos:
nomes = ['Arya', 'Samson', 'Dora', 'Tim', 'Ollivandader']
print(max(nomes))  # Vai localizar o 'Tim', pois está levando em consideração a ordem alfabética
print(min(nomes))  # Vai licalizar o 'Arya', pois está levando em consideração a ordem alfabética
print('-----')

# Como encontrar o maior nome? Vamos alterar o comportamento padrão do max()
print(max(nomes, key=lambda nome: len(nome)))  # Vai buscar o que possui mais caracteres
print('-----')

"""
O que estamos fazendo é:
Para cada nome, na lista de nomes, vamos ordenar pelo tamanho dos nomes.

E como saber se posso fazer essas alterações?
Faça no terminal:
help(max): lá temos um parâmetro que recebe uma função

Ou, use o ctrl na função max(). Acho que esse meio mais recomendado
"""

musicas = [
    {"título": 'Rap', "tocou": 3},
    {"título": 'MPB', "tocou": 32},
    {"título": 'Sertanejo', "tocou": 21},
    {"título": 'Rock', "tocou": 80},
    {"título": 'Serenata', "tocou": 17}]

print(f"A música que mais tocou:\n{max(musicas, key=lambda nome: nome['tocou'])}")
print(f"A música que menos tocou:\n{min(musicas, key=lambda nome: nome['tocou'])} ")
print('-----')

# Desafio: imprimir apenas o título da música mais/menos tocada
print(f"O título da música mais tocada: {max(musicas, key=lambda nome: nome['tocou'])['título']}")
print(f"O título da música menos tocada: {min(musicas, key=lambda nome: nome['tocou'])['título']}")

# Essa sacada de enxergar a própria função como objeto, e pedir a chave, foi muito bom

# Desafio: como encontrar a música mais/menos tocada sem o max/min e sem o lambda?

max = 0

for musica in musicas:
    if musica['tocou'] > max:
        max = musica['tocou']

for musica in musicas:
    if musica['tocou'] == max:
        print(f"O título da música que mais tocou com o loop for: {musica['título']}")

"""
Veja que dá muito mais trabalho sem o max e as expressões lambdas.
"""
------------------------------------------------------------------------------------------------------------------

"""
REVERSED

Obs.: não confunda com a função reverse() que estudamos nas listas

- A função reverse() é aplicado apenas sobre as listas
- A função reversed é aplicado para qualquer iterável. Ou seja, sua função é inverter um iterável.

"""

# Exemplos
lista = [1, 2, 3, 4, 5]

res = reversed(lista)
print(res)
print(type(res))

"Ou seja, a função reversed() retorna um iterável do tipo <class 'list_reverseiterator'>"

# Mas podemos converter este tipo:

# lista
print(list(reversed(lista)))

# tupla
print(tuple(reversed(lista)))

# set (conjunto), lembrando que em conjuntos, não definimos a ordem dos elementos
print(set(reversed(lista)))

# Podemos iterar sobre o reversed()

for letra in reversed('Francisco'):
    print(letra, end='')  # lembrando que o end desabilita a quebra automática de linha

print('\n')  # para pular uma linha

# Podemos fazer sem usar o for
print(''.join(list(reversed('Francisco'))))  # join transforma uma lista de string em uma string
print('-----')
# também podemos usar o slice de string
print('Francisco'[::-1])

print('-----')
# podemos fazer um loop for reverso
for i in reversed(range(0, 10)):
    print(i)

print('-----')
# lembrando que também podemos fazer com o próprio range
for n in range(9, 0, -1):
    print(n)

------------------------------------------------------------------------------------------------------------------

"""
Len, Abs, Sum e Round

len(): retorna o tamanho
abs(): retorna o valor absoluto de um número inteiro ou real
sum(): recebe como parâmetro um iterável e retorna a soma total dos elementos + um valor inicial (default=0)
round(): retorna um número arredondado para n digítos de precisão após a casa decimal. Se a precisão não for informada
retorna o inteiro mais próximo da entrada
"""
lista = [1, 2, 3, 4, 5]


# tamanho
print(len(lista))
print('-----')

# Valor absoluto
print(abs(-3))
print('-----')

# soma
print(sum(lista))
print(sum(lista, 5))
print(' ')
print(sum((3.15, 3.17)))

print(sum((1, 2, 3, 4, 5)))

print(sum({1, 2, 3, 4, 5}))

print(sum({'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}.values()))  # Estamos dizendo que queremos somar os valores
print('-----')

# arredondar

print(round(10.2))

print(round(10.5))

print(round(10.6))

print(round(1.2112121212121, 2))  # arredonda para duas casas decimais após a vírgula





------------------------------------------------------------------------------------------------------------------

"""
Zip(): cria um iterável (Zip Object) que agraga elemento de cada um dos iteráveis passados como entrada em pares.

Muito legal, gostei dessa função
"""

lista1 = [1, 2, 3, 4, 5]
lista2 = [6, 7, 8, 9, 10]

zip1 = zip(lista1, lista2)  # poderíamos ter mais iteráveis como argumento do zip

print(zip1)
print(type(zip1))
print('-----')

# Vamos visualizar esses agrupamento?

print(list(zip1))  # Gera uma lista contendo tuplas para cada par

print(tuple(zip1))  #

print(set(zip1))

print(dict(zip1))
print('-----')

# Poderíamos ter:
zip2 = zip(lista1, 'abc')  # Veja que esse tipo de dado fica apenas em memória, temos que colocar antes de cada print.
print(zip2)  # veja que é um objeto do tipo zip: <zip object at 0x000001B44B210240>
print(' ')  # para dar um espaço
print(list(zip2))

zip2 = zip(lista1, 'abc')
print(tuple(zip2))  # veja que temos tupla dentro de tupla

zip2 = zip(lista1, 'abc')
print(set(zip2))

zip2 = zip(lista1, 'abc')  # vai gerar apenas chave e valor
print(dict(zip2))

# veja o que acontece se o tamanho dos iteráveis no argumento do zip forem difentes... veja que o 16 e o 17 não entram
# pois leva em conta o iterável de menor tamanho, que no caso são lista 1 e lista 2.
lista3 = [10, 11, 12, 13, 15, 16, 17]
zip3 = zip(lista1, lista2, lista3)  # veja o que acontece se mudar a ordem dos elementos
print(list(zip3))
print('-----')

# podemos usar para diferentes iteráveis
tupla = 1, 2, 3, 4
lista = [1, 2, 3, 4]
dicionario = {'a':1, 'b':2, 'c':3, 'd':4}

zt = zip(tupla, lista, dicionario.values())
print(list(zt))

# Veja isso, vamos desempacotar com o asterisco. Lembra dele? lá do *args e **kwargs

dados = [(1, 2), (3, 4), (5, 6), (7, 8)]
zp = zip(*dados)
print(list(zp))
print('-----')

# Veja esse exemplo mais complexo. No qual precisamos gerar um dicionário com a maior nota de cada estudante.

prova1 = [80, 91, 78]
prova2 = [70, 92, 75]
alunos = ['Raissa', 'Luiza', 'Francisco']

# apenas o zip
print(list(zip(alunos, prova1, prova2)))
print('-----')
# lembra dessa estrutura de compreensão: dictionary comprehension?
final = {dado[0]: max(dado[1], dado[2]) for dado in zip(alunos, prova1, prova2)}
print(final)
print('-----')
"""
Veja que dado[0] é a chave, ou seja, o nome de cada estudante.
O max vai pegar a maior nota entre a nota 1 e a nota 2, ou seja, será o valor do nosso dicionário.
"""

# veja outra forma de fazer esse mesmo procedimento. Lembre-se que o Map recebe uma função e um iterável

final = zip(alunos, map(lambda nota: max(nota), zip(prova1, prova2)))
print(dict(final))

"""
Veja que o zip vai criar pares entre alunos e map.
Veja que map vai gerar as maiores notas. Percebea que map() recebe uma função e um iterável.
"""

------------------------------------------------------------------------------------------------------------------

"""
RAISE

Levantando os próprios erros com o raise.

raise: não é uma função, é uma palavra reservada assim como o def. O raise gera erros
O raise é útil quando queremos criar nossas próprias excessões e mensagens de erros.

Forma geral:

raise TipoDoErro('mensagem de erro')

Nota: O raise, assim o return, finaliza nossa função.
"""

# raise ValueError('Valor incorreto')

# Exemplo real


def colore(texto, cor):
    cores = ['azul', 'branco']
    if type(texto) is not str:
        raise TypeError('Texto precisa ser uma string.')
    if type(cor) is not str:
        raise TypeError('Cor precisa ser uma string.')
    if cor not in cores:
        raise ValueError(f'A cor precisa ser uma entre: {cores}')
    print(f"O texo: '{texto}', será impresso na cor: '{cor}'")


colore('Hoje é sexta-feira', 'azul')




------------------------------------------------------------------------------------------------------------------

"""
O BLCO TRY/EXCEPT

obs.:
try = tente
except = capture a exceção

Utilizamos o bloco try/except para tratar erros que podem ocorrer no nosso código. Prevenindo, assim, que o programa
pare de funcionar e o usuário recebe mensangens de erro inesperadas. Se o erro não for tratada, pode fazer o usuário
perder a confiança em nossa aplicação.

Forma mais simples de utilzar:

try:
    //execução problemática (tente fazer isso)
except:
    //o que deve ser feito em caso de problema
"""

# Exemplo 1 - Tratando um erro genérico (qualquer tipo) - não é recomendado. O recomendado é tratar de forma específica.

try:
    geek()
except:
    print('Deu Algum problema.')

"Em palavras: tente executar a funçõa geek(), caso encontre erros imprima: Deu Algum problema."

print('Veja que conseguimos tratar o erro para que o código continue.')
print('-----')

# Exemplo 3 - Tratando um erro específico
try:
    geek()  # gera NameError
    # len(5) # Gera TypeError
except NameError:  # ou seja, capturamos apenas o erro do tipo NameError. Se o erro for de outro tipo, não será tratado.
    print('Você está utilizando uma função inexistente')
print('-----')


# Exemplo 4 - Podemos apelidar nossos erros
try:
    len(5)
except TypeError as err:  # err é um apelido padrão
    print(f'A aplicação gerou o seguinte erro: {err}')
print('-----')

# Exemplo 5 - Diversos tratamentos de erro de uma única vez

try:
    len(5)
except NameError as erra:  # Veja que não temos erro. Mas se tivesse, seria detectado.
    print(f'Deu NameError: {erra}')
except TypeError as errb:
    print(f'Deu TypeError: {errb}')
print('-----')


# Exemplo 6 - Criando uma função para capturar um erro dentro da função

def pega_valor(dicionario, chave):
    try:
        return dicionario[chave]
    except KeyError:
        return None


dic = {'nome': 'Francisco'}
print(pega_valor(dic, 'game'))

------------------------------------------------------------------------------------------------------------------

"""
Try / Except / Else/ Finally

Obs.:
- usar try/except é comum
- usar else/finally não é comum

Quando saber que devemos tratar um erro?
Dica:
Toda entrada de dado deve ser tratada!

Nota:
A função do usuário é DESTRUIR seu sistema.

Dica ao tratar erros: Tratar sempre no começo
"""
"""
# Else - executa a linha a apenas se não ocorrer o erro. Podemos ter um else para cada exept.
try:
    num = int(input('Informe um número: '))
except ValueError:
    print('Valor incorreto!')
else:
    print(f'Você digitou: {num}')
print('-----')

# Finally - o menos interessante
try:
    num = int(input('Informe um número: '))
except ValueError:
    print('Você não digitou um valor válido!')
else:
    print(f'Você digitou o número: {num}')
finally:
    print('Executando o finally')
"""
"""
Nota:
O bloco finally sempre será executado, independente se houve exceção ou não. Ou seja, no fim do dia
faz o mesmo papel tiver apenas o print da linha 32. Experimente tirar o finally de lá.

Então, por que executá-lo? Para fechar ou desalocar recursos. Ou seja, para encerrar conexões de arquivos para escrita 
ou leitura, ou para encerrar conexão com banco de dados por exemplo.
"""


# Exemplo mais elaborado de tratamento de erro


def dividir(a, b):
    try:
        return int(a) / int(b)
    except (ValueError, ZeroDivisionError) as err:
        return f'Ocorreu algum problema: {err}'


num1 = input('Informe o primeiro número: ')
num2 = input('Informe o segundo númeor: ')

print(dividir(num1, num2))

------------------------------------------------------------------------------------------------------------------

"""
DEBUGANDO COM PDB

PDB: Python Debugger
Bub: inseto

É importante saber qual o valor de uma variável em determinado ponto.
"""
# Forma amadora


def dividir(a, b):
    print(f'a={a}, b={b}')
    try:
        return int(a) / int(b)
    except (ValueError, ZeroDivisionError) as err:
        return f'Ocorreu algum problema: {err}'


print(dividir(4, 7))

# Exemplo com o PyCharm (break point)
"""
Para isso, dê um break point na linha 34 e 36, depois clique na joaninha. Depois perceba os valores dos argumentos
na frente da def.
Você pode selecionar "int(a) / int(b)", clicar com o botão direito, selicionar Add To Watches para ver o resultado da 
execução do código. Além disso, pode clicar no ócular para criar outra janela.

F8 para pular as linhas durante a execução do debugging
"""
print('-----')


def dividir(a, b):
    try:
        return int(a) / int(b)
    except (ValueError, ZeroDivisionError) as err:
        return f'Ocorreu algum problema: {err}'


print(dividir(4, 7))

# Exemplo com o PDB - Python Debugger (para qualquer IDE)
"""
Precisamos* importar a biblioteca pdb e então utilizar a função set_trace(). Nesse caso, podemos clicar apenas no run.
Comandos básicos do PDB
l: lista onde estamos no código
n: próxima linha
p: imprime a variável
c: continua a execução - finaliza o debugging
"""

"""
# Exemplo 1

import pdb

nome = 'Francisco'
sobrenome = 'Araújo'
pdb.set_trace()
nome_completo = nome + ' ' + sobrenome
curso = 'Programação em Python: Essencial'
final = nome_completo + ' faz o curso ' + curso
print(final)
"""

# Exemplo 1 - Novidade, quando queremos executar dois comandos em uma mesma linha devermos separar por ponto e vírgula.


nome = 'Francisco'
sobrenome = 'Araújo'
import pdb; pdb.set_trace()
nome_completo = nome + ' ' + sobrenome
curso = 'Programação em Python: Essencial'
final = nome_completo + ' faz o curso ' + curso
print(final)


"""
Explicando o asterisco na linhas 47. A partir do Python 3.7 não é mais necessário importar a biblioteca pdb, pois o 
comando de debug foi incorporado como função built-in (integrado) chamado breakpoint()
"""
print('-----')

# Exemplo 2 - Aplicando com a nova função função integrada do Python (breakpoint()) - Veja que surge EOF

nome = 'Francisco'
sobrenome = 'Araújo'
breakpoint()
nome_completo = nome + ' ' + sobrenome
curso = 'Programação em Python: Essencial'
final = nome_completo + ' faz o curso ' + curso
print(final)
print('-----')

# Nota: Cuidado com conflitos entre nomes de veriáveis e os comandos do pdb
# Exemplo 3 - Antes, para imprimir algo deveríamos digitar o nome da variável. Agora (p nomeVariável)


def soma(l, n, p, c):
    breakpoint()
    return l + n + p + c


print(soma(1, 2, 3, 5))


------------------------------------------------------------------------------------------------------------------

"""
MÓDULO RANDOM

O que são módulos? Outros arquivos em Python
Por que criar módulos? Para deixar o programa mais simples e para poder reutilizar o código.

Nota:
- Um módulo pode ser criado por qualquer programdar e também pode ser compartilhado na comunidade.
- Um conjunto de módulos cria um pacote

Módulo Random: Possui várias funções para gerar números pseudo-aleatórios (pois repete números).

"""

# Existem duas formas de utilzar um módulo ou função deste

# Forma 1 - Importanto todo o móudulo (não recomendado)

import random

# random: gera um número pseudo-aleatório entre 0 e 1

""" 
Ao realizar o import de todo o módulo, todas as funções, atributos, classes e propriedades  que estiverem dentro do
módulo ficarão disponíveis (ficarão em memória). Caso você saiba quais funções precisa usar deste módulo, vamos aprender
no próximo exemplo.

Faça no terminal: import random, dir(random) e depois help(random.random) para abrir a documentação
"""

print(random.random())  # Primeiro é o nome do pacote e depois o nome da função que queremos utilzar (separados por '.')

# Nota: Ctrl+botãoDireito no pacote random para vizualizar todas as funções contidas nesse pacote
print('-----')
# Forma 2 - Importando uma função específica do módulo (recomendado)

# digamos que queremos apenas a função random() desse pacote random


from random import random


# Ou seja, do pacote random queremos importar a função random. Perceba que os parênteses surgem apenas na execução.
# Percebe também que na utilização não precisamos mais referenciar assim: random.random() para utilizar.


for i in range(10):  # gera 10 números
    print(random())  # usamos a função random() como se fosse nossa
print('-----')


# Forma 3 - função uniform(): gera números do tipo float pseudo-aleatório entre os valores estabelecidos

from random import uniform

for i in range(10):  # Gera 10 números
    print(uniform(3, 7))  # lembre que o sete não será incluído
print('-----')


# Forma 4 - função randint(): gera números do tipo int pseudo-aleatório entre os valores estabelecidos

from random import randint

for i in range(6):  # gera 6 números
    print(randint(3, 7), end=',')  # Nesse caso, o sete será incluído. Vamos imprimir na mesma tela separados por ','
print('\n')
print('-----')


# Forma 5: função choice(): mostra um valor aleatório de um iterável
from random import choice

jogadas = ['pedra', 'papel', 'tesoura']
print(choice(jogadas))  # Jogadas também poderia ser uma string (ele sortearia uma letra desss string)
print('-----')


# forma 6: função shuffle(): embaralha os dados
from random import shuffle

cartas = ['K', 'Q', 'J', 'A', '2', '3', '4', '5', '6', '7']
print(cartas)  # original


shuffle(cartas)
print(cartas)  # após o embaralhamento
print(f'Sua carta: {cartas[0]}')

# ou, podemos embaralhar e retirar a última carta para o usuário (tipo um sorteio mesmo)
print(cartas.pop())  # lembra do pop? ele retira e mostra o último elemento de uma lista.
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
TRABALHANDO COMO MODULOS BUILTIN

- São módulos integrados que já vem instalados no python

Quando o Python é instalado:
 ________________________
|Python|Múdulos Builtins|
------------------------

No entanto, quando estamos usando a linguagem Python, o módulos builtins não carregados.
No terminal faça:
Python
dir()

E veja que lá tem o módulo builtins. Depois, faça:
dir(__builtins__)

Vejá que lá já tem todas as funções instaladas. Para carregar algumas delas para nosso uso, devemos importar
(import random, por exemplo)

Dica: Uma boa prática, seria pesquisar pela documentação no site do python.org/módulos. Lá tem bastante exemplo. Vale
muito apena pesquisar.

site: https://docs.python.org/3/py-modindex.html
"""

# Utilizando alias (apelidos) para módulos/funções
import random as rdm
print(rdm.random())
print('-----')

# Podemos importar todas as funções de um módulo utilizando o *

from random import *
print(random())
print('-----')
"""
Importante: veja que pressupõe-se que você já saiba o nome da função (random()). Além disso, a chamada da função é 
diferente, pois do outro modo:

import random
print(random.random())
"""

# Podemos dar um apelido para função também
from random import randint as rdi
print(rdi(5, 89))
print('-----')

# Importando duas funções e dando apelido para as duas

from random import randint as rdi, random as rdm
print(rdi(5, 89))
print(rdm())
print('------')

# Às vezes, a partir de um módulo queremos fazer vários imports

"Maneira confução"
from random import random, randint, uniform, shuffle, choice

"Maneira profissional, utilizando tuple para vários imports. Um import em cada linha seria o ideal"
from random import (random,
                    randint,
                    uniform,
                    shuffle,
                    choice)

print(random())
print(randint(1, 2))
print(uniform(2, 6))
lista = ['a', 'b', 'd']
shuffle(lista)
print(lista)
print(choice('Francisco Araújo'))






------------------------------------------------------------------------------------------------------------------

"""
MÓDULOS CUSTOMIZADOS (criados por nós mesmo)

Como módulos python nada mais são do que arquivos python, então, todos os arquvios que criamos neste curso são módulos
Python prontos para serem utilizados.
"""

# Exemplo
# from nomeDoScript import nomeDaFuncao

# Importando todos os elementos de um módulo
# from nomeDoScrip

------------------------------------------------------------------------------------------------------------------

"""
MÓDULOS EXTERNOS

Obs.: Gostei muito desse pacote

- Utilizamos o gerenciadro de pacotes chamado Pip - Python Installer Package
- No terminal faça: pip
- Veja que surgirá uma lista de comandos
- Para consultar os pacotes externos existentes:  https://pypi.org
- Para instalar um pacote faça no terminal: pip install nomeDoPacote
- Instale: pip install colorama
- Para atualizar a versão do seu pip faça no terminal: pip install --upgrade pip (peguei essa informaçãoao ao instalar
um pacote)
- Você será avisado se tentar instalar um pacote que já está instalado na sua máquina

Fore: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.
Back: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.
Style: DIM, NORMAL, BRIGHT, RESET_ALL

"""
"""
from colorama import (init,
                      Fore,
                      Back,
                      Style)
init()

print(Back.CYAN + 'Francisco Araújo da Silva')  # altera o plano de fundo
print(Fore.BLUE + "Francisco Araújo")  # altera a cor da letra

print(Style.BRIGHT + "Texto")
print(Style.RESET_ALL)
print('Francisco Araújo')
"""
# Vamos criar um arquivo pdf
"""
No terminal faça:
pip install python-pdf

import pydf
pdf = pydf.generate_pdf('<h1>this is html</h1>')
with open('test_doc.pdf', 'wb') as f:
    f.write(pdf)
    
    
Por algum motivo deu erro quando fui criar.
"""



------------------------------------------------------------------------------------------------------------------

"""
PACOTES

Módulo: Apenas um arquivo Python com diversas funções.
Pacote: Diretório contendo uma coleção de módulos.


Nota: Nas versões 2.x do Python, um pacote Python deveria conter dentro dele um arquivo chamado __init__.py
na versões do Python 3.x, não é mais obrigatório a utilização deste arquivo. Mas normalmente ainda é utilizado para
manter compatibilidade

Para criar um pacote:
Botão direito em cima do do projeto/new/python package

Para criar um módulo
Botão direito sobre o pacote/python file

- um arquivo __init__.py será criado apenas para identificar que estamos em um pacote. Este arquivo é vazio.
- veja que podemos criar um pacote dentro de outro

Uma vez que o pacote foi criado, você pode acessar a conta do Python, se registrar, publicar o seu pacote. Caso ele
seja interessante.

Dica: O módulos não são criados apenas para publicar, mas também para organizar nossos códigos
"""

# Agora vamos usar nossos pacotes (Criados no pacote: primeiro_pacote)

from primeiro_pacote import modulo1  # Do pacote: primeiro_pacote, estamos importando o módulo: modulo1
print(modulo1.pi)  # podemos ter acesso a essa variável
print(modulo1.funcao1(3, 3))  # podemos ter acesso a essa função
print('-----')
# Acessando um submódulo - gostei dessa jogada

from primeiro_pacote.sub_pacote import (sub_modulo1,
                                        sub_modulo2)
print(sub_modulo1.funcao3())
print(sub_modulo2.funcao4())
print('-----')

# Também podemos importar apenas uma função do PACOTE.
from primeiro_pacote.modulo1 import funcao1
print(funcao1(5, 5))


# Também podemos importar apenas uma função do SUBPACOTE.
from primeiro_pacote.sub_pacote.sub_modulo1 import funcao3
print(funcao3())

------------------------------------------------------------------------------------------------------------------

"""
DUNDER NAME E DUNDER MAIN

Dunder: Doble Under
Dunder Name: __name__
Duncer Main: __main__

- Os Dunders são criados para não gerar conflitos com variáveis, atributos ou funções criados criadas por nós aqui no
Python. Pois, veja que se executarmos um módulo em Python diretamente na linha de comando, internamente o Python
atribuirá à variável __name__ o valor __main__ indicando que este módulo é o módulo de execução principal.

Faça no terminal:
dir(): perceba que lá tem vários dunders. Além disso, vejá que lá tem __name__
faça: print(__name__), veja que será retornado __main__
"""
from funcoes_com_parametro import soma_impares

print(soma_impares([1, 2, 3, 5]))  # os dois prints estão sendo executados apenas pelo import da linha 13 e 16.
# perceba que mesmo o print sendo comentado ainda assim executamos os dois prints apenas pelo import (isso naõ deveria
# acontecer em um programa real do python. É agora que o método dunder entre.
"""
Para corrigir, faça:
if __name__ == '__main__':  se o nome do arquivo for main (principal), execute o arquivo diretamente, e não pelo import.
    lista = [1, 2, 3, 4, 5, 6, 7]
    print(soma_impares(lista))

    tupla = (1, 2, 3, 4, 5, 6, 7)
    print(soma_impares(tupla))
    
Todo arquivo python python contém a variável __name__, se a função for executada na linha de comando, a variável 
__name__ vai ter o valor __main__ e então executamos os prints. 

Assim, agora temos um módulo (funcoes_com_parametro) real do Python.
Veja que agora temos apenas o print que nos interessa


Agora, veja que os dunders são muito usados no módulos python. Vá ao final da documentação do módulo random da aula
52:

if __name__ == '__main__': se o módulo está sendo executado diretamente (é uma verificação)
    _test()
    
Ou seja, essa verifica diz se o módulo foi feito para se executado diretamente ou não.

- Veja que lá não tem nenhum print.
- Os dois prints do módulo são executados apenas quando executados no próprio módulo.

Resumo:
se o arquivo foi executado diretamente vai se chamar: __main__ 
se o arquivo for importado vai se chamar __name__: proprioNomeDoArquivo
"""




------------------------------------------------------------------------------------------------------------------

"""
LEITURA DE ARQUIVOS:

Para ler o conteúdo de uma arquivo em Python, utilizamos a função integrada open(). Por padrão, já está no modo de
leitura "r"

open(): Na forma mais simples de utilização passamos apenas um parâmetro de entrada, que nesse caso é caminho do arquivo
a ser lido. Essa função retorna um _io.TextIOWrapper e é com ele que trabalharemos

https://docs.python.org/3/library/functions.html#open

Obs.: por padrão, a função open() abre o arquivo para leitura. Esse arquivo deve existir, caso contrário
teremos o erro  FileNotFoundError

"""
# Exemplo:
arquivo = open('59a - texto.txt', encoding='UTF-8')  # Por padrão, my escrita não era "UTF-8", por isso tive que forçar
print(arquivo)
# ret = arquivo.read()  # O parâmetro (posição) do read sinaliza até onde queremos ler. Lá o cursor fica parado
# print(type(ret))  # Tipo string
print('-----')
"""
<_io.TextIOWrapper name='59a - texto.txt' mode='r' encoding='cp1252'>
name: nome do arquivo
'r': indica que é apenas um modo de leitura. r: read(), ou seja, apenas para ler
encoding: diz respeito a atualização. Não é importante. Mas o padrão seria UTF-8 (99,9% dos casos)
"""
print(type(arquivo))
print('----')


# Para ler o conteúdo de um arquivo após a abertura
print(arquivo.read())  # ele lê a primeira linha e o cursor fica no fim
print(arquivo.read())  # Não vai repetir o print porque o cursor já está no fim.
# Ou seja, não tem nada do fim pra frente

------------------------------------------------------------------------------------------------------------------

"""
SEEK E CURSORS:

Seek: Utilizado para mover o cursor pelo arquivo
"""
"""
arquivo = open('59a - texto.txt', encoding='UTF-8')
print(arquivo.read())
print(arquivo.read())  # Não lê nada

# Movimentando o cursor com a função seek()

# A função seek(): recebe um parâmetro que indica onde queremos colocar o cursor. Esse parâmetro pode se qualquer valor

arquivo.seek(0)  # volta o curso para a posição 0
print(arquivo.read())

arquivo.seek(5)
print(arquivo.read())
"""

"""
Problema do read(): Lê todo o nosso conteúdo. Dependendo do tamanho do arquivo pode ser um problema.
Solução: readline(): Lê linha a linha do nosso conteúdo
"""

# arquivo = open('59a - texto.txt', encoding='UTF-8')
# print(arquivo.readline())   # Lê a primeira linha
# print(arquivo.readline())   # Lê a segunda linha

"""
ret = arquivo.readline()
print(type(ret))  # É sempre bom saber o tipo para que possamos saber o que podemos fazer como o tipo
print(ret.split(' '))  # transforma a string em uma lista a cada espaço.
"""

# Colocando colocando cada lista do texto como sendo um elemento de uma lista. Útil para saber quantas linhas temos.
# print(len(arquivo.readlines()))
# print(arquivo.readlines())  # lista de linhas do texto


"""
Quando abrimos um arquivo com a função open() uma conexão é criada entre o arquivo no disco do computador e o nosso
programa. Essa conexão é chamada de streaming. Então, ao finalizar a aplicação com o arquivo devemos fechar essa 
conexão. Para isso, usamos a função close()

Passor para trabalhar com arquivo
1: Abriro arquivo;
2: Trabalhar o arquivo;
3: Fechar o arquivo para evitar problemas para um segundo uso.
"""

# 1
arquivo = open('59a - texto.txt', encoding='UTF-8')

# 2
print(arquivo.read())
print(arquivo.closed)  # Verifica se o arquivo está fechado ou aberto. True=fechado, False=aberto

# 3
arquivo.close()  # Para usar o arquivo abaixo novamente, é preciso abrir novamente
print(arquivo.closed)



------------------------------------------------------------------------------------------------------------------

"""
BLOCO WITH:

O bloco with - Para não precisar fazer o fechamento do arquivo. Dentro do with está aberto! Fora está fechado

Passos para se trabalhar com arquivo:
1 - abrir o arquivo
2 - manipular o arquivo
3 - fechar o arquivo (nós, manualmente)

O bloco with é usado para criar um contexto de trabalho onde os recursos utilizados são fechados após o bloco with.
"""

# o bloco with
with open('59a - texto.txt', encoding='UTF-8') as arquivo:  # forma pythônica de trabalhar com arquivos
    print(arquivo.readlines())  # imprime cada linha como um elemento da lista

# print(arquivo.readlines())  # a operação não existe fora do with

------------------------------------------------------------------------------------------------------------------

"""
ESCREVENDO EM ARQUIVOS:

 - Quando abrimos para leitura, podemos apenas ler, sem escrever
 - Quando abrimos pra escrita, pdemos apenas escrever, sem ler
 - Para ler ou escrever precisamos abrir o arquivo
 - Abrimos com o open, mas agora, não no formato leitura "r"

-Quando abrimos no formato escrita, um arquivo é criado no sistema operacinal
-A função write recebe apenas string como parâmetro

Obs.: Na escrita:
Abrindo um arquivo para escrita  como o modo 'w': se o arquivo não existir um será criado; caso ele já exista, o
anterior será apagado
"""

# exemplo. Precisamos criar um novo arquivo.
with open('62a - novo.txt', 'w', encoding="UTF-8") as arquivo:  # w: write
    arquivo.write('Podemos acrescentar uma linha no texto. \n')
    arquivo.write('Podemos acrescentar outra. \n')
    arquivo.write('Podemos acrescentar quantas quisermos. \n')
    # arquivo.write(2) TypeError, pois só aceita string

# Escrevendo várias vezes o mesmo arquvivo
print('-----')

with open('62b - novo_arquivo', 'w', encoding='UTF-8') as novoarquivo:
    novoarquivo.write('Francisco Araújo\n'*100)

# Recebendo dados do usuário e escrevendo
with open('62c - frutas', 'w', encoding='UTF-8') as arq:
    while True:
        fruta = input("Digite a fruta que deseja adicionar ou digite 'sair' para finalizar: ")
        if fruta != 'sair':
            arq.write('-'+fruta + '\n')   # or na próxima linha: arq.write('\n')
        else:
            break

print('-----')


------------------------------------------------------------------------------------------------------------------

"""
MODOS DE ABERTURA DE ARQUIVO:

r: abre para leitura
w: abre para escrita - sobrescreve caso o arquivo já exista.
x: abre para escrita somente se o arquivo não existir

http://docs.python.org/3/library/functions.html#open

a: abre para escrita, adiciona o conteúdo ao final do arquivo, como o append. Um arquivo é criado se não existir. Se
existir, será adicionado. ESSE É MUITO INTERESSANTE


E para escrever no início do arquivo?
Não sei ainda. Nem adianta usar seek(0). Me parece que sempre será adicionado no começo

with open('62a - novo.txt', 'a', encoding='UTF-8') as arkiu:
    arkiu.seek(0)  # Não adianta
    arkiu.write('Escrevendo no começo!')
"""
"""
with open('63a - beach.txt', 'x', encoding='UTF-8') as qualquer:
    qualquer.write('Teste de conteúdo.\n')


# Ou seja aplicação é executada apenas uma vez. Num próximo run gera erro

# Refatorando para não gerar erro
try:
    with open('63a - beach.txt', 'x', encoding='UTF-8') as qualquer:
    qualquer.write('Teste de conteúdo.\n')
except FileExsistsError:
    print('Arquivo já existe') # gera um aviso

"""


"""
with open('62c - frutas', 'a', encoding='UTF-8') as arq:
    while True:
        fruta = input("Digite a fruta que deseja adicionar ou digite 'sair' para finalizar: ")
        if fruta != 'sair':
            arq.write('-'+fruta + '\n')   # or na próxima linha: arq.write('\n')
        else:
            break
"""


------------------------------------------------------------------------------------------------------------------

"""
STRINGIO:

StringIO: Utilizado para ler e criar arquivos EM MEMÓRIA, pois nem sempre temos permissão para ler um arquivo

Para ler ou escrever em um arquivo do sistema operacional, é preciso ter permissão:
    -Permissão para leitura: Podemos ler o arquivo
    -Permissão para Escrita: Para criar o arquivo

EM MEMÓRIA: pois não vai gravar no disco, vai ficar apenas na memória do computador.
"""

# Primeiro: Fazemos o import
from io import StringIO  # no módulo  io import a função StrngIO

mensagem = 'É uma primeira mensagem que ficará em memória. Parece sentimento póstumo, mas é apenas um procedimento.'

# Podemos criar um arquivo em memória já com uma string inserida ou mesmo vazio para depois inserismos texto
arquivo = StringIO(mensagem+'\n')  # criando um arquijo já com um texto dentro dele

# é equivalente a: arquivo = open('arquivo.txt', 'w'), nesse caso, um arquivo (arquivo.txt) é criado

# Tendo o arquivo, agora, podemos manipular o mesmo normalmente.
print(arquivo.read())  # Veja que nenhuma arquivo será criado. Apenas criado em memória. A leitura foi feita em memória

# Inserindo novo texto
arquivo.write('Outro texto...')  # veja que será escrito no final da variável "arquivo"
print('-----')

# Podemos até manipular o cursor
arquivo.seek(0)  # cursor no início do arquivo
print(arquivo.read())

"Um diferencial da stringIO é que podemos abrir para escrita e leitura rapidamente."

------------------------------------------------------------------------------------------------------------------

# SISTEMA DE ARQUIVOS - NAVEGAÇÃO

# Nem sempre temos uma interface gráfico onde podemos realizar operações - como nos computadores, onde podemos fazer
# praticamente tudo manualmente. Principalmente ao criar e publicar uma operação, onde os dados ficam em servidores. Nos
# servidores não existe interface gráfica, não existe mause, o que existe é apenas uma janela de comando.

# - Os computadore armazenam dados em arquivos
# - Os arquviso são organizados em diretórios (pastas)
# - Diretório raiz (root), o principal
# - Diretório root no windows: C:\
# - Path: caminho completo do arquivo até o diretório onde ele está armazenado
#    - Absolute (da raiz até o arquivo)
#    - Relative: \..\ move um diretório acima na hierarquia
#                \.\ mostra o diretório corrente

# C:\users\meuNome\nomeDoArquivo.extensao


# Para fazer uso de manipulação de arquivos do sistema operacional, precisamos importar e fazer uso do módulo os.
# os: Operating System - Sistema de operação


# Fazendo o import
import os
import sys
"""
# getcwd('..'): retorna o path absoluto
print(os.getcwd())  # Por algum motivo, a função não foi executada ao usar aspas triplas no script.

# chdir(): Para mudar um diretorio acima
os.chdir('..')
print(os.getcwd())

os.chdir('..')
print(os.getcwd())

os.chdir('..')
print(os.getcwd())

os.chdir('..')  # não existe mais diretório além da raiz.
print(os.getcwd())
"""

""""""
# Podemos checar se um diretório é relativo ou absoluto
print(os.path.isabs('C:\\Users\\franc\\PycharmProjects\\CodePython'))  # se for True é absoluto, se for False é relativo
print('-----')

# Nota: Faça print(francisco\\araujo)  veja que uma a barra será eleminada. Se usar apenas uma dá erro.

# Podemos identificar o sistema operacional com o módulo os
print(os.name)  # nt para Windows e posix para linux e mac. Também é possível descobri com Crtl+(botãoDireito) em name.
print('-----')


print(sys.platform)  # win32

# Podemos listar os diretórios
print(os.listdir())  # Cria uma lista de todos os arquivos e diretórios aqui do nosso projeto.

# Também posso passar um caminho
print(os.listdir("C:\\"))

------------------------------------------------------------------------------------------------------------------

"""
ENTENDENDO ITERATORS E ITERABLES


Iterator:
    - um objeto da programção que pode ser iterado
    - um objeto que retorna um dado, sendo um elemento por vez quando uma função next() é chamada

Iterable:
    - um objeto que irá retornar um iterator quando a função iter() for chamada
"""
# exemplos de iterable
nome = 'Francisco'
numeros = [1, 2, 3, 4, 5, 6]

# print(next(nome)) # vair gerar uma erro, pois não é iterator
# print(next(numeros))

# podemos transfomar um iterable em um iterator

it1 = iter(nome)
it2 = iter(numeros)

print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print(next(it1))
print('-----')
print(next(it2))
print(next(it2))
print(next(it2))
print(next(it2))
print(next(it2))
print(next(it2))
print('-----')
# Por baixo dos panos
for letra in nome:
    print(f'{letra}')

"""
Veja que por baixo dos panos o laço for verifica a variável 'nome', reconhe que é um 'iterable',
 aplica o iter() e depois o next(). O next() é na verdade o print sentdo aplicado no laço.
"""

------------------------------------------------------------------------------------------------------------------

"""
CRIANDO SUA PRÓPRIA VERSÃO DE LOOP

Por quê? Porque precisamos etender a fundo como esses laços funcionam.
"""


def meu_for(iteravel):
    it = iter(iteravel)
    while True:
        try:
            print(next(it))
        except StopIteration:
            break


meu_for([1, 2, 4, 5, 6])

------------------------------------------------------------------------------------------------------------------

"""
ESCREVENDO UM ITERADOR CUSTOMIZADO

O objetivo é criar algo com a mesma funcionalidade do range()
"""
# É preciso entender um pouco de programação orientada a objetos.


class Contador:  # contador não é um iterable
    def __init__(self, menor, maior):
        self.menor = menor  # atributo da classe
        self.maior = maior

    def __iter__(self):  # converter o iterable em um iterator (obrigatório)
        return self

    def __next__(self):  # aplicado no objeto do tipo iterator (obrigatório)
        if self.menor < self.maior:
            numero = self.menor
            self.menor = self.menor + 1
            return numero
        raise StopIteration

# em classe, não é função, é método de classe. __init__: construtor (cria o objeto a partir da classe)


con = Contador(1, 6)
it = iter(con)  # segundo método da classe sendo aplicado
print(next(it))  # terceiro método da classe sendo aplicado

# Para melhorar
for n in Contador(1, 61):
    print(n)

# No formato range()
for i in range(1, 61):
    print(i)

------------------------------------------------------------------------------------------------------------------

"""
GERADORES

- Geradores (generators) são iteradores (iterators)
    - Obs.: A recíproca não é verdadeira, nem todo iterators é um generator
- Generators podem ser criados com funçõe geradoras
- Funções geradoras utilizam a palavra reservada yield
- Generators podem ser criados com expressões geradoras


Diferenças entre Funções e Generator Functions;
 ..............................................................................
|FUNÇÕES                             |GENERATORS FUNCTIONS                    |
-------------------------------------------------------------------------------
|utlizam retur                       |utilizam yield                          |
-------------------------------------------------------------------------------
|retona uma vez, ou none             |podem utilizar yield múltiplias vezes   |
-------------------------------------------------------------------------------
|quando executada, retorna um valor  |quando executada, reotorna um generator |

"""
# Exemplo de Generators Function


def conta_ate(valor_maximo):
    contador = 1
    while contador <= valor_maximo:
        yield contador  # yiel, é com se fosse o return, ele retorna contador.
        contador = contador + 1


"""
Nota: lembre-se, o return finaliza a função, já o yiel não encerra a função, ele fica esperando o próximo next().
Um GENERATOR FUNCTION não é um GENERATOR. Ele gera um GENERATOR.
"""
# 1
gen = conta_ate(5)
# print(type(gen)) # <class 'generator'>
# print(next(gen))  # 1
# print(next(gen))  # 2
# print(next(gen))  # 3
# print(next(gen))  # 4
# print(next(gen))  # 5


# 2
# print(next(gen))  # 1
# print('-----')
# for num in gen:  # começa a partir do 2, gerar um por vez
#    print(num)


# 3 para gerar todos de uma vez
print(list(conta_ate(6)))

------------------------------------------------------------------------------------------------------------------

"""
TESTE DE MEMÓRIA COM GENERATORS

- Quando usar GENERATORS? quando queremos ter um baixo consumo de memória!
- Ter baixo consumo de memória não está relacionado com alta velocidade de processamento.
"""

# Sequência de fibonacci (usando listas) - a lista é gerada toda de uma vez (ocupa mais memória)


def fib_lista(maxi):
    nums = []
    a, b = 0, 1
    while len(nums) < maxi:
        nums.append(b)
        a, b = b, a + b
    return nums


# teste: usou 450 MB
# for n in fib_lista(100):
#    print(n)

# Sequência de fibonacci (usando geradores) - geramos número um a um (ocupa menos memória)
def fib_gen(maximo):
    a, b, contador = 0, 1, 0
    while contador < maximo:
        a, b = b, a + b
        yield a
        contador = contador + 1


# teste: usou 3,5 MB
for n in fib_gen(10000):
    print(n)

------------------------------------------------------------------------------------------------------------------

"""
TESTE DE VELOCIDADE COM EXPRESSÕES GERADORAS

"""
"""
# Generators (Geradores)


def nums():
    for num in range(1, 10):
        yield num


ge1 = nums()
print(ge1)  # generator
print(next(ge1))
print(next(ge1))

print('-----')


# Generation Expression

ge2 = (num for num in range(1, 10))
print(ge2)  # generator expression
print(next(ge2))
print(next(ge2))
"""

# Usando várias funções integradas
print(sum(num for num in range(1, 10)))  # some (número para cada número no range*
# nota: "num for num in range(1, 10)" é uma expressão geradora
print('-----')


# Realizando teste de velocidades
import time

# Generator Expression

gen_inicio = time.time()  # tempo atual
print(sum(num for num in range(100_000)))
gen_tempo = time.time() - gen_inicio
print('-----')
# List Comprehension
list_inicio = time.time()  # tempo atual
print(sum([num for num in range(100_000)]))  # veja os colchetes do list comprehension
list_tempo = time.time() - list_inicio
print('-----')

print(f'Tempo de Generators Expression: {gen_tempo} s')  # mais veloz
print(f'Tempo de List Comprehension: {list_tempo} s')  # menos veloz

------------------------------------------------------------------------------------------------------------------

"""
FUNÇÕES DE MAIOR GRANDEZA (HIGHER ORDER FUNCTIONS - HOF)

- O que isso significa?
    - Quando uma linguagem de programação suporta HOF indica que podemos ter funções que retornam outras funções como
    resultado ou mesmo que podemos passar funções como argumento para outra funções, e até mesmo criar
    variáveis do tipo de funções nos nossos programas

Nota: na seção de funções, já utilizamos

- Em Python, as funções são cidadãos de primeira classe.

- os decoradores em Python nos ajudam a adicionar comportamento ao nosso código.
"""
from random import choice

# Exemplo - Definindo as funções


def somar(a, b):
    return a + b


def diminuir(a, b):
    return a - b


def multiplicar(a, b):
    return a * b


def dividir(a, b):
    return a / b


def calcular(num1, num2, funcao):
    return funcao(num1, num2)  # estamos retornando a execução da função


# Testando as funções:
print(f' A soma: {calcular(4, 2, somar)}')
print(f' A Subração: {calcular(4, 2, diminuir)}')
print(f' A multiplicação: {calcular(4, 2, multiplicar)}')
print(f' A divisão: {calcular(4, 2, dividir)}')
print('-----')


# Nested Functions - Funções Aninhadas
"""
Em Python, podemos ter funções dentro de funções (Nested Functions ou Inner Functions)
"""

# Exemplo


def cumprimento(pessoa):

    def humor():  # função interna (função aninhada - função dentro de função)
        return choice(('E ai, ', 'Suma daqui! ', 'Gosto muito de você...♥ '))
    # choice: seleciona, aleatoriamente, um dos elementos
    return humor() + pessoa  # estamos executando a função, observe os parênteses

# Testando


print(cumprimento('Francisco'))
print(cumprimento('Anna'))
print('-----')


# Retornando funções de outras funções


def faz_me_rir():
    def rir():
        return choice(('hahahahah ', 'kkkkkkkkkkk ', 'yayayayayayay '))
    return rir  # veja que estamos retornando a função, e não a execução da função - sem os parênteses


# Testando
rindo = faz_me_rir()
print(rindo())
print('-----')

# Inner Functions podem acessar o escopo de funções mais externas.
# A função humor() poderia acessar o escopo da função cumprimento()
# A função rir() poderia acessar o escopo da função faz_me_rir()

# exemplo


def faz_me_rir_novamente(pessoa):
    def dando_risada():
        risada = choice(('hahahahah ', 'kkkkkkkkkkk ', 'yayayayayayay '))
        return f'{risada} {pessoa}'
    return dando_risada   # estamos apenas retornando a função, e não executando - sem os parênteses


# Testando
rindo = faz_me_rir_novamente('Francisco')  # a variável recebe a execução da função
print(rindo())  # estamos executando a variável com se fosse a função
print(rindo())


------------------------------------------------------------------------------------------------------------------

"""
DECORADORES (DECORATORS)

O que são decoradores?
    - São funções
    - Envolvem outras funções e aprimoram (decoram o que você já tem) seu comportamento
    - São exemplos de Higher Order Function
    - Possui sintaxe própria, usando "@" (Syntact Sugar / Açucar Sintático)
    - Geralmente, uma função decorator recebe como parâmetro uma função, pois estamos decorando a função que está sendo
    passada como argumento

...........................................
|           Function Decorator            |
-------------------------------------------

...........................................
|                Function                 |
-------------------------------------------

Nota:
Não confunda Decorator com Decorator Function
    - Decorator
                        @seja_educado_mesmo
    - Decorator function:
                        def seja_educado_mesmo(funcao):
                            def sendo_mesmo():
                            print('Foi um prazer conhecer você!')
                            funcao()
                            print('Tenha um excelente dia.')
                        return sendo_mesmo

"""

# Decoradores como funções - Sintaxe não recomendada / Sem açucar Sintático -------------------------------------------


def seja_educado(funcao):  # função principal que tem como argumento outra função
    def sendo():  # função interna
        print('Foi um prazer conhecer você!')
        funcao()  # executa a função
        print('Tenha um ótimo dia.')
    return sendo  # Retorna a função interna, e não a execução da função


def saudacao():
    print('Seja bem-vido(a) à programação!')


# Testando 1
saudacao()

print('-----')
teste = seja_educado(saudacao)
teste()
# estamos decorando a função saudacao com a função seja_educado. Estamos aprimorando o comportamento da função saudacao
print('-----')


# Testando 2
def raiva():
    print('EU TE ODEIO!')


raiva_educada = seja_educado(raiva)
raiva_educada()
print('-----')

# Decoradores como funções - Sintaxe recomendada /  açucar Sintático --------------------------------------------------
# É muito melhor de enxergar


def seja_educado_mesmo(funcao):
    def sendo_mesmo():
        print('Foi um prazer conhecer você!')
        funcao()
        print('Tenha um excelente dia.')
    return sendo_mesmo


@seja_educado_mesmo  # Forma recomendada e mais utilizada. Vemos que '@seja_educado_mesmo' decora 'apresentando'
def apresentando():
    print('Meu nome é Francisco.')

# Testando 3


apresentando()
print('-----')

# Testando 4


@seja_educado_mesmo
def dormir():
    print('Quero dormir.')


dormir()

------------------------------------------------------------------------------------------------------------------

"""
DECORATORS COM DIFERENTES ASSINATURAS  (funções docoradoras com diferentes parâmetros de entrada)

Quando a funcão a ser decorada tiver mais de um argumento, como no caso da função ordenar:
    - usamos Decorator Pattern


- A assinatura de uma função é representada pelo seu retorno, nome e parâmetros de entrada.
"""

# Relembrando


def gritar(funcao):
    def aumentar(nome):
        return funcao(nome).upper()  # Aplicando caixa alta no resultado da função
    return aumentar


@gritar
def saudacao(nome):  # saudacao está decorado com a função gritar()
    return f'Olá, eu sou o {nome}'


@gritar
def ordenar(principal, acompanhamento):  # ordenar está decorado com a função gritar
    return f'Olá, eu gostaria de {principal}, acompanhado de {acompanhamento}, por  favor.'


# Testando
print(saudacao('Francisco'))
print('-----')

"""
print(ordenar('Picanha', 'Batata Frita')):
    vai gerar erro, temos que usar Decorator Pattern
"""

# Refatorando


def gritar_refatorado(funcao):
    def aumentar(*args, **kwargs):
        return funcao(*args, **kwargs).upper()
    return aumentar


@gritar_refatorado
def saudacao_refatorado(nome):
    return f'Olá, eu sou o {nome}'


@gritar_refatorado
def ordenar(principal, acompanhamento):
    return f'Olá, eu gostaria de {principal}, acompanhado de {acompanhamento}. Por favor.'


print(saudacao('Francisco'))
print(ordenar('Picanha', 'Batata Frita'))
print('-----')

# também posso ter função sem argumento


@gritar_refatorado
def lol():
    return 'lol'


print(lol())
print('------')


# Obs.: Vale lembrar que podemos utilizar parâmetros nomeados

print(ordenar(acompanhamento='Salada', principal='Arroz'))  # quando nomeamos, não precisamos inserir na ordem.
print('-----')

# Decorator com argumentos


def verifica_primeiro_argumento(valor):  # Função decoradora
    def interna(funcao):  # recebe a função que está sendo decorada
        def outra(*args, **kwargs):  # realiza validações
            if args and args[0] != valor:
                return f'Valor incorreto! Primeiro argumento precisa ser {valor}'
            return funcao(*args, **kwargs)
        return outra
    return interna


@verifica_primeiro_argumento('pizza')  # pelas validações, obrigando o primeiro argumento a ser pizza
def comida_favorita(*args):
    return args


@verifica_primeiro_argumento(10)
def soma_dez(num1, num2):
    return num1 + num2


# Testando
print(soma_dez(10, 20))  # vai somar
print(soma_dez(15, 15))  # não vai somar
print('-----')

print(comida_favorita('pizza', 'churrasco'))  # executa
print(comida_favorita('churrasco', 'pizaa'))  # não executa

------------------------------------------------------------------------------------------------------------------

"""
PRESERVANDO METADATA COM WRAPS

Metadados: são dados intrínsecos em arquivos
wraps: funções que envolvem elementos com diferentes finalidades
"""

# Problema


def ver_log(funcao):  # função decoradora
    def logar(*args, **kwargs):
        """Eu sou uma função (logar) dentro de outra"""
        print(f'Você está chamando {funcao.__name__}')  # __name__: retorna o nome da função
        print(f'Aqui a documentação: {funcao.__doc__}')  # __doc__: retorna a documentação da função
        return funcao(*args, **kwargs)
    return logar


@ver_log
def soma(a, b):
    """Soma dois números"""
    return a + b


# print(soma(10, 30))

# Veja o problema. Em um projeto real, isso gera muita dor de cabeça por alguns dias até encontrar a fonte de erro
print(soma.__name__)  # o nome deveria ser 'soma'
print(soma.__doc__)  # a documentação deveria ser 'Soma dois números'
print('-----')

"""
Pense no seguinte caso: você resolve publicar uma biblioteca com essa fonte de erro, o que aconteceria se outra pessoa
resolvesse consultar a documentação dos seus códigos? Ou seja, não basta que o código execute corretamente. É preciso 
que a documentação também esteja de acordo.
"""


# Para resolver este problema precisamos importar um decorator da própria linguagem Python.

# Resolução do problema
from functools import wraps


def ver_log(funcao):  # função decoradora
    @wraps(funcao)  # resolvendo o problema com apenas esta linha de código. Wraps preserva os metadatas das funções. -
    def logar(*args, **kwargs):
        """Eu sou uma função (logar) dentro de outra"""
        print(f'Você está chamando {funcao.__name__}')  # __name__: retorna o nome da função
        print(f'Aqui a documentação: {funcao.__doc__}')  # __doc__: retorna a documentação da função
        return funcao(*args, **kwargs)
    return logar


@ver_log
def soma(a, b):
    """Soma dois números"""
    return a + b


print(soma.__name__)  # o nome deveria ser 'soma'
print(soma.__doc__)  # a documentação deveria ser 'Soma dois números'
print('-----')

------------------------------------------------------------------------------------------------------------------

"""
FORÇANDO TIPOS DE DADOS COM UM DECORADOR

- Sabemos que em Python, não definimos tipos de dados. O Python determina o tipo de acordo com o conteúdo da variável.
- No entanto, em algums casos é preciso forçar o tipo de dado para evitar algum problema.
"""

# Exemplo


def forca_tipo(*tipos):  # veja que '*tipos' equivale ao '*args'
    def decorador(funcao):
        def converte(*args, **kwargs):  # o *args é imutável, por isso temos que criar uma nova variável
            novo_args = []
            for (valor, tipo) in zip(args, tipos):  # zip: une em pares os valores de um iterável
                novo_args.append(tipo(valor))  # str('Francisco'), int('3')
            return funcao(*novo_args, **kwargs)
        return converte
    return decorador


@forca_tipo(str, int)  # estamos a forçando 'msg' a ser uma string e 'vezes' ser um inteiro
def repete_msg(msg, vezes):
    for vez in range(vezes):
        print(msg)


repete_msg('Francisco', '4')
print('-----')


@forca_tipo(float, float)
def dividir(a, b):
    print(a / b)


dividir('2', 4)

------------------------------------------------------------------------------------------------------------------

"""
Programação Orientada a Objetos - POO
Paradigmas de programação: Depende da linguagem.
 - Programação estrutural; liguangem C, Já não entre aqui
 - orientada a objeto; A liguagem C não consegue usar essa paradigma, java
 - programaçõa funcional;

Python: multparadigma

Programação orientada a objeto, mapeia o objeto do mundo real para modelos computacinais, capaz de descrever seu
comportamento na vida real:
    Componentes:
        - classe: Modelo do objeto do munod real sendo representado computacinalment
            nome (atributo)
            preco (atributo)
            desconto (atributo)
        - Atributos: característica do objeto. Uma clase pode ou não ter atributos

        - metodos (funções): comportamento do objeto, ações que o objeto pode ter
             (Notebook, valor, desconto): Construtor
             (Caneta BIC, valor, desconto) Construtor

        - Construtor (um método especial): utilizado para criar os objetos a partir da classe
            Obejetos ou instâncias: elementos criados a partir da classe

Criando classes: definindo nosso próprio tipo de dado
"""

numero = 10
print(numero)
print(type(numero))
print('-----')


class Produto:
    pass


"""
Uma classe que não faz nada, o pass é apena para indentar. Diz que podemos passar. Sem atributo, sem método
"""

ps4 = Produto()
print(ps4)
print(type(ps4))


"""
Produto() - Construtor padrão da classe, o próprio nome dela. Ele é um método, devido ao parênteses
ps4 - Objeto da classe Produto

No console:
0x0000021ABBCE1570: Onde o objeto está alocado na memória.
Agora, temos um tipo de dado chamado produto.
"""


------------------------------------------------------------------------------------------------------------------

"""
POO - Classes

Em POO, Classe são modelos objetos do mundo real sendo representados computacionalment
Classes podem conter:
    - Atributos > Representam as características do objeto. Ou seja, pelos atributos conseguimos representar
                  computacionalmente os estados de um objeto. No caso da Lâmpada, se ela é 110 ou 220 volts, se
                  ela é branca, amarela, vermelha ou qual sua luminosidade

    - Métodos (funções) > Representam os comportamentos dos objetos. Ou seja, as ações que este objeto pode realizar
    no seu sistmea. No caso da Lâmpada, queremos ligar ou desligar



Em Python, parfa definir uma classe, usamos a palavra reservada 'class'

pass (passe) - quando temos um bloco de código que ainda não está implementado. Ou seja, não estamos fazendo nada na
classe

OBS.: Ao nomear as classes, a inicial de NOSSA classe deve ser maiúscula. se o nome for composto, as inicias de ambas as iniciais
devem ser maiúsculas.


Em computação não usamos acentuação, caracteres especiais, espaços ou similares

Obs.: Quando estamos planejando um software e definimos quais classes teremos que ter no sistema, chamamos estes objetos
que serão mapeados para classes de entidade (Lampada, Produto, Usuario)
"""
idade = 32  # classe tipo int
preco = 2340  # classe tipo floa
nome = 'Francisco Araújo'  # classe tipo string
lampada = 'lampada'  # não tem uma classe do tipo lâmpada


class Lampada:
    pass


lamp = Lampada()
print(type(lamp))

"""
Agora temos uma classe do tipo Lampada. Acabamos de trazer um objeto do mundo real para o mundo
computacional.

Em java, o nome da classe principal deve ser o nome do arquivo java.
Aqui, em python, podemos criar mais de uma classe em um único arquivo.
"""


class Produto:
    pass


class Usuario:
    pass


valor = int('32')  # cast
print(help(int))  # o int é uma classe interna do Python. O Python cria as classes com inicial minúscula

------------------------------------------------------------------------------------------------------------------

"""
POO - Atributos
Recomendação: ver esta aula mais de uma vez

Atributos - Representam as características do objeto. Ou seja, pelos atributos conseguimos representar
computacionalmente os estados de um objeto.

Em Python, dividimos os atributos em 3 grupos:
    - Atributos de instância;
    - Atributos de classe;
    - Atributos dinâmicos


# Atributos de instância: São atributos declarados dentro do método construtor.

Obs.: Método construtor (__init__): método especial utilizado para a construção do objeto

Em java: Veja como é muito mais complicado

public class Lampada(){
    private int voltagem;
    public String cor;
    pretected Boolean ligada = false;

    public Lampada(int voltagem, String cor){
        this.Voltagem = voltagem;
        this.cor = cor;
    }

}


Agora, vamos fazer o equivalente, veja que é muito mais simples em python.
"""

# CLASSES COM ATRIBUTOS PÚBLICOS ---------------------------------------------------------------------------------------


class Lampada:
    def __init__(self, voltagem, cor):  # __init__ é o método construtor (constrói o objeto)
        self.voltagem = voltagem
        self.cor = cor
        self.ligada = False


class ContaCorrente:
    def __init__(self, numero, limite, saldo):
        self.numero = numero
        self. limite = limite
        self.saldo = saldo


class Produto:
    def __init__(self, nome, descricao, valor):
        self.nome = nome
        self.descricao = descricao
        self.valor = valor


class Usuario:
    def __init__(self, nome, email, senha):
        self.nome = nome
        self.email = email
        self.senha = senha


"""
- Os atributos de instâncias são declarados dentro do próprio método construtor
- Nosso private é duplo underline (__)
- é no método construtor que fazemos a declaração dos atributos.
- Assim como no java, esses atributos são privados, só posso ter acesso a eles dentro da clase

Para cada classe temos o próprio método construtor (__init__). __init__ é um método (função)
Toda função dentro de uma classe é chamado de método.


- self? Lembrar de restaurante self-service. Quem serve o prato é você mesmo. Ou seja, auto serviço.

self > O objeto que está executando o método

- Atributos de instância são declarados dentro do método construtor
"""

# ps4 = Produto()  # Produto() é o método __init__ sendo executado. O () é a execução do método construtor


"""
A palavra 'self' é apenas uma convenção. 
O primeiro parâmetro de um método é sempre o self, o próprio objeto
"""


class Bar:
    def __init__(bar, nome, idade):  # Ao passar o mouse por cima, veja que ele recomenda usar self.
        bar.nome = nome
        bar.idade = idade


print('-----')

"""
bar.nome > O objeto bar, no atributo nome, vai receber nome
"""


"""
Temos: Atributos Públicos e Privados - em relação a visibilidade
Atributos de instâncias podem ser públicos ou privados


Em java:
Atributo PRIVADO - pode ser acessado apenas dentro da própria classe que ele foi declarado.


Atributo PÚBLICO - pode ser acessado em qualqur parte do código
Por exemplo, eu posso acessar o atributo número da classe ContaCorrente dentro da classe Produto

Atributo PROTECTED - visível apenas dentro do pacote na qual o atributo se encontra.

Em Python: Por convenção, todo atributo  de uma classe é público. Ou seja, pode ser acessado em todo o projeto.
Caso queiramos que determinado atributo deve ser tratado como privado, ou seja, que deve ser acessado/utilizado semente
dentro da própria classe onde está declarado. 
Use: __ duplo underscore no início de seu nome. É conhecido como Name Mangling

"""


# CLASSE COM ATRIBUTOS PRIVADOS ----------------------------------------------------------------------------------------

class Acesso:
    def __init__(self, email, senha):
        self.email = email  # Atributo público: .
        self.__senha = senha  # Atributo privado: __    > não temos acesso de forma tradicional

    def mostra_senha(self):
        print(self.__senha)  # veja que podemos acessar um atributo privado dentro de uma classe sem problema algum

    def mostra_email(self):
        print(self.email)
# Obs: Lembre-se que isso é apenas uma conveção, ou seja, a linguagem Python não vai te impedir o acesso aos
# atritos sinalizados como privados fora da classe.

# exemplo

user = Acesso('Francisco@gmail', 123232.2)  # aqui estamos fora da classe.
print(user.email)  # Podemos acessar
print('-----')

# print(user.__senha)  # AttributeError, diz que nessa classe não temos o atributo senha


"""
user > instância, um objeto da classe acesso
"""

print(dir(user))  # veja no console
print('-----')

print(user._Acesso__senha)   # Name Mangling
"""
veja que agora temos acesso ao atributo senha. Agora faz sentido a nota da linha 130.
A recomendação é que você não acesso um atributo privado. Já que não faz sentido implementar para acessar depois.
"""


print((type(user._Acesso__senha)))


print('----')
user.mostra_senha()
user.mostra_email()
print('-----')


"""
O que significa atributos de instância?
Significa, que ao criarmos instâncias/objetos de uam classe, todas as instâncias terão estes atributos
"""
user1 = Acesso('user1@gmail.com', '123')  # tem email e senha
user2 = Acesso('user2@gmail.com', '345')  # tem email e senha

user1.mostra_email()
user2.mostra_email()

"Temos dois objetos(user1 e user2), cada um tem o seu dado"
print('-----')

"""Atributo de classes"""
p1 = Produto('Playstation 4', 'Video Game', 2300)
p2 = Produto('Xbox S', 'Video Game', 4500)
# Cada instância terá seus próprios valores pra eles
# Atributos de classe são declarados diretamente na classe. Ou seja, fora do construtor. Geralmente, já inicializamos
# um valor, e este valor é compartilhado entre todas as instâncias das classe. Ou seja, ao invés de cada instância da
# da classe ter seus próprios valores como é o caso dos atributos de instância, com os atributos de classe todas as
# instâncias terão o mesmo valor para este atributo. Fez total sentido depois da aplicação


# Refatorando a classe produto


class Produto:
    # Atributo de classe. Em java, também conhecido com atributo estático
    imposto = 1.05  # 0.05 % de imposto. Veja, não sentido este imposto ser um atributo de instância. Já que cada
    # produto terá o seu imposto. Esse Atributo de classe será o mesmo pra cada instância da classe.

    def __init__(self, nome, descricao, valor):
        self.nome = nome
        self.descricao = descricao
        self.valor = (valor * Produto.imposto)


p1 = Produto('Playstation 4', 'Video Game', 2300)
p2 = Produto('Xbox S', 'Video Game', 4500)
print(p1.valor)  # Acesso possível, mas incorreto de um atributo de classe
print(p2.valor)  # Acesso possível, mas incorreto de um atributo de classe
print('-----')
# Obs.: Não precisamos criar uma instância de uma classe para fazer acesso a um atributo de classe
print(Produto.imposto)  # Acesso correto de um atributo de classe
print('-----')
# Refatorando a classe Produto


class Produto:
    imposto = 1.05
    contador = 0  # Atributo contador inicializado em zero. Ou seja, todo produto quando for criado vai ser
    # inicializado em zero

    def __init__(self, nome, descricao, valor):
        self.id = Produto.contador + 1  # Cria um id e soma 1 ao contador. id é um atributo de instância
        self.nome = nome
        self.descricao = descricao
        self.valor = (valor * Produto.imposto)
        Produto.contador = self.id  # No fim da criação do produto, atualiza o contador. O contador é atributo de classe

"""
Sobre o id: Ele é um atributo de instância. Mas veja que não estamos recebendo ele como parâmetro dentro do bloco
construtor. Não somos obrigados a recebeder todos os atributos de instância como parâmetro
"""
p1 = Produto('Playstation 4', 'Video Game', 2300)  # Primeiro produto, id = 1
p2 = Produto('Xbox S', 'Video Game', 4500)  # Segundo produto, id = 2
''

print(p1.id)
print(p2.id)


"""
Nota: para atributos de instância, uma memória para cada objeto é criada. Por outro lado, quando criamos atributos
 de classe, todos os dados ficam apenas em um espaço na memória do computador. 
 
 Por exemplo:
 Aqui: 
p1 = Produto('Playstation 4', 'Video Game', 2300)
p2 = Produto('Xbox S', 'Video Game', 4500)

Temos 8 espaço, um espaço para cada atributo.

Aqui:
imposto = 1.05
contador = 0

Temos 2 espaço
"""


"""Atributos Dinâmicos. """

"""
Atributos Dinâmicos: Não é comum, mas existe. É um atributo de instância que pode ser criado em tempo de execução.
Esse atributo será excluso da instância que o criou.
"""
print('------')


class Produto:
    imposto = 1.05
    contador = 0

    def __init__(self, nome, descricao, valor):
        self.id = Produto.contador + 1
        self.nome = nome
        self.descricao = descricao
        self.valor = (valor * Produto.imposto)
        Produto.contador = self.id


p1 = Produto('Playstation 4', 'Video Game', 2300)
p2 = Produto('Xbox S', 'Video Game', 4500)

# Criando um atributo dinâmico em tempo de execução
p2.peso = '5kg'  # Note que, na classe Produto, não existe o atributo peso
print(f'Produto: {p2.nome}, Descrição: {p2.descricao}, Valor: {p2.valor}, Peso: {p2.peso}')
print('-----')

# Deletando atributos

"Propriedade dos objetos: __dict"
print(p1.__dict__)  # Cria um dicionário, mas não mostra os atributos de classe
print(p2.__dict__)
print('-----')

del p2.peso  # Atributo dinâmico

print(p1.__dict__)
print(p2.__dict__)
print('-----')

del p2.valor  # Atributo de instância

print(p1.__dict__)
print(p2.__dict__)

------------------------------------------------------------------------------------------------------------------

"""
POO - Métodos

- Métodos (funções) - representam o comportamento do objeto. Ou seja, as ações que este objeto pode realizar no seu
sistema.

Em Python, dividimos os métodos, assim como os atributos, em 2 grupos:
 - Método de instânica
 - Método de classe

 Vamos criar atributos privados para ter segurança. Ou seja, acessar os atributos apenas dentro da classe
"""

# Método de instância
"""
O método dunder __init__ é um método especial chamado de construtor e sua função é construir o objeto a partir da 
classe.

Todo elemento em Python que inicia e finaliza com duplo underline é chamado de dunder (Double Underline).

Os métodos/funções dunder em Python são chamados de métodos mágicos.

Não é recomendado que nós, programadores, criemos métodos dunders. Pois podemos dar o azar de criar um dunder que já
existe internamente (vários dunders)

Quando uma função está contida dentro de uma classe ela é chamada de método, ou métodos de instância.
Métodos de instância: pois precisamos de uma instância da classe para utilizá-los

Métodos são escritos em letras minúsculas. Se o nome for composto, o nome terá as palavras separadas por underline

"""


class Lampada:

    def __init__(self, cor, voltagem, luminosidade):  # init é o método construtor, o objetivo é construir o objeto
        self.__cor = cor
        self.__voltagem = voltagem
        self.__luminosidade = luminosidade
        self.__ligada = False


class ContaCorrente:
    contador = 4999

    def __init__(self, limite, saldo):
        self.__numero = ContaCorrente.contador + 1
        self.__limite = limite
        self.__saldo = saldo
        ContaCorrente.contador = self.__numero


class Produto:
    contador = 0

    def __init__(self, nome, descricao, valor):
        self.id = Produto.contador + 1
        self.__nome = nome
        self.__descricao = descricao
        self.__valor = valor
        Produto.contador = self.id

    def desconto(self, porcentagem):
        """
        :param porcentagem: Porcentagem de desconto
        :return: Retorna o valor do produto com o desconto
        """
        return (self.__valor * (100 - porcentagem))/100


class Usuario:
    def __init__(self, nome, sobrenome, email, senha):  # __init__  Método interno do Python
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.senha = senha

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'


"""
p1 = Produto('Playstation 4', 'Video Game', 2300)
print(p1.desconto(20))  # precisamos de uma instância para acessar o método

# print(Produto.desconto(20))  -> Gera erro, assim não conseguimos. Precisamos da instância.
print(Produto.desconto(p1, 40))  # Outra maneira de fazer. Mas ainda precisamos da instância.
"""
user1 = Usuario('Francisco', 'Araújo', 'Franciscoaraujo2016f2@outlook.com', '123')
user2 = Usuario('Lara', 'Siqueira', 'LaraSiqueira2016f2@outlook.com', '456')

print(f'Nome completo: {user1.nome_completo()}')
print(Usuario.nome_completo(user1))
print('-----')
print(f'Nome completo: {user1.nome_completo()}')
print(Usuario.nome_completo(user2))

"""
Método de instânicia: é um método que está dentro de uma classe.
"""

# print(f'Senha user 1: {user1._Usuario__senha}')  # Acesso de forma errada de um atributo de classe
## print(f'Senha user 1: {user1._Usuario__senha}')  # Acesso de forma errada de um atributo de classe
print('-----')

from passlib.hash import pbkdf2_sha256 as cryp
""" Pacote de criptografia extramente poderoso"""


class Usuario:
    def __init__(self, nome, sobrenome, email, senha):  # __init__  Método interno do Python
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.__senha = cryp.__hash__(senha, rounds=200000, salt_sizer=16)
        # string que quer encriptar. Rounds, número de embaralhamento. Tamanho do texto que deve se juntar com outro
        # para gerar o embaralhamento

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'

    def checa_senha(self, senha):  # Recebe a senha, e verifica a senha recebida se igual a senha do objeto instanciado
        if cryp.verify(senha, self.__senha):  # verifica se senha = self.senha
            return True
        return False


"""
Deu um erro aqui.

# Para criar um usuário.
nome = input('Informe o nome: ')
sobrenome = input('Informe o sobrenome: ')
email = input('Informe o e-mail: ')
senha = input('Informe a senha: ')
confirma_senha = input('Confirme a senhaa: ')

if senha == confirma_senha:  # se a senha for igual, vamos instanciar
    user = Usuario(nome, sobrenome, email, senha)  # usa as variáveis anteriores
else:
    print('Senha não confere...')
    exit(1)

print('Usuário criado com sucesso!')

senha = input('Informe a senha para acesso: ')

if user.checa_senha(senha):
    print('Acesso permitido.')
else:
    print('Acesso negado.')

print(f'Senha User Criptografada: {user.Usuario_senha}')

Métodos de instancia, então, trabalha com valores da instancia do objeto
"""


"""
Métodos de classe.
- Não estão vinculados a nenhuma instancia da classe, mas sim, diretamento a ela.
- Usamos decoradores.
"""


class Usuarios:

    contador = 0

    @classmethod  # Decorador. Necessário para usar um método de classe

    def conta_usuarios(cls):  # argumento cls, é a própria classe.
        print(f'Temos {cls.contador} usuário(s) no sistema.')

    def __init__(self, nome, sobrenome, email, senha):
        self.__id = Usuarios.contador + 1
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.__senha = senha
        Usuarios.contador = self.__id

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'

    def ver(self):  # veja que, como esse método não faz acesso a nenhum atributo de instância, ele recomenda usar
        print('ver')      # método de classe


# Antes, para acessar o contador:
#Usuarios.contador


# Agora

user = Usuarios('Francisco', 'Araújo', 'gmail', '123')


user4 = Usuarios.conta_usuarios()  # Forma correta, nome_da_classe.metodo_de_classes. Via nome da classe
user.conta_usuarios() # Possível, mas incorreta. Via instância da classe.



"""
Quando usar método de clase é método de instancia?
Basta olhar na estrutura acima

Métodos de instâncias: quando o método precisa fazer acesso a atributos de instância

Método de classe: Não fazemos acesso à métodos de instância, e nem teria como fazer. Pois não temos acesso ao self. Ou
seja, a instância.
Métodos de classe, aqui no Python, são conhecidos como métodos estáticos em outras linguagens

def ver(self):  # veja que, como esse método não faz acesso a nenhum atributo de instância, ele recomenda usar
    print('ver')      # método de classe

"""


# MÉTODOS PRIVADOS (duplo __ no começo do método): Refatorando a classe usuarios:
"Assim como temos atributos públicos e privados, também temos métodos públicos e privados"


class Usuarios:

    contador = 0

    @classmethod  # Decorador. Necessário para usar um método de classe
    def conta_usuarios(cls):  # argumento cls, é a própria classe.
        print(f'Temos {cls.contador} usuário(s) no sistema.')

    def __init__(self, nome, sobrenome, email, senha):
        self.__id = Usuarios.contador + 1
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.__senha = senha
        Usuarios.contador = self.__id
        print(f'Usuário criado: {self.__gera_usuario()}')

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'

    def __gera_usuario(self):
        return self.__email.split('@')[0]  # separa o email no '@', gera uma lista, retorna o 1° elemento da lista.
    # split e slice de string.



"""
user5 = Usuarios('Francisco', 'Araújo', 'Francisco@gmail.com','123')  # só tenho acesso à classe __gera_usuario dentro
# da classe.

# print(user5.__gera_usuario())  # veja que ele não imprime. Pois não temos acessso a esse método fora da classe.
print(user5._Usuarios__gera_usuario())  # Tenho acesso, mas não é recomendado
"""

"""
MÉTODOS DE ESTÁTICOS AQUI NO PYTHON. Muito parecidos com métodos de classe.
Sem acesso a classe e sem acesso a instâncias
"""


class Usuarios:

    contador = 0

    @classmethod  # Decorador. Necessário para usar um método de classe
    def conta_usuarios(cls):  # argumento cls, é a própria classe.
        print(f'Temos {cls.contador} usuário(s) no sistema.')

    @staticmethod
    def definicao():  # Sem acesso a classe e a instâncias
        return 'UXR344'

    def __init__(self, nome, sobrenome, email, senha):
        self.__id = Usuarios.contador + 1
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.__senha = senha
        Usuarios.contador = self.__id
        print(f'Usuário criado: {self.__gera_usuario()}')

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'

    def __gera_usuario(self):
        return self.__email.split('@')[0]


print('-----')
print(Usuarios.contador)  # 0 porque ainda não instanciamos nenhum usuario
print(Usuarios.definicao())
user6 = Usuarios('Francisco', 'Araújo', 'Francisco@gmail.com','123')
print(user6.contador)
print(user6.definicao())
------------------------------------------------------------------------------------------------------------------

"""
OBJETOS

- Objeto e instância é a mesma coisa.
- Objetos são instâncias da classe. Após mapear o objeto do mundo real para sua representação computacional, podemos
criar quantos objetos forem necessários. Instâncias são variáveis do tipo definido na classe.

- Para instanciar um objeto é preciso informar os parâmetros (atributos) que ele possui no método construtor
"""


class Lampada:

    def __init__(self, cor, voltagem, luminosidade):
        self.__cor = cor
        self.__voltagem = voltagem
        self.__luminosidade = luminosidade
        self.__ligada = False  # toda lâmpada quando for construída terá o atributo ligada como falso

    def checa_lampada(self):  # um método que checa se lâmpda está ligada ou desligada
        return self.__ligada

    def ligar_desligar(self):  # se o método for executado: se a lâmpada tiver ligada, vamos desliga, e vice-versa.
        if self.__ligada:  # se o atributo ligada for True
            self.__ligada = False
        else:
            self.__ligada = True


class Cliente:

    def __init__(self, nome, cpf):
        self.__nome = nome
        self.__cpf = cpf

    def diz(self):
        print(f'O cliente {self.__nome} diz oi.')


class ContaCorrente:

    contador = 4999

    def __init__(self, limite, saldo, cliente):
        self.__numero = ContaCorrente.contador + 1
        self.__limite = limite
        self.__saldo = saldo
        self.__cliente = cliente
        ContaCorrente.contador = self.__numero

    def mostra_cliente(self):
        print(f'O cliente é: {self.__cliente._Cliente__nome}')  # fazendo acesso a self.__cliente e acesso ao atributo
                                                                # privado ._Cliente__nome


class Usuario:

    def __init__(self, nome, sobrenome, email, senha):
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__email = email
        self.__senha = senha


# instânica do tipo lâmpada
# lamp1 = Lampada()  # Gera erro, temos que inserir os argumentos do método construtor
lamp1 = Lampada('branca', 110, 60)
lamp1.ligar_desligar()  # inicialmente, a lâmpada está desligada. Quando o método for executado, ela será ligada
# lamp1.ligar_desligar() # desligaria a lâmpada
print(f'A lâmpada está ligada? {lamp1.checa_lampada()}')
print('-----')


# instânica do tipo conta corrente
cliente1 = Cliente('Francisco Araújo',  '1111.1111.1111.95')
cc1 = ContaCorrente(500, 10000, cliente1)  # veja que o teceiro atributo é o objeto Cliente
cc1.mostra_cliente()  # veja que temos acesso ao nome do cliente
cc1._ContaCorrente__cliente.diz()  # Forma incorreta. De dentro de ContaCorrente tenho acesso a métodos e atrinutos da
# classe Cliente.
print('-----')


# instância do tipo usuário
user1 = Usuario('Francisco', 'Araújo', 'franciscoaraujo2016f2@outlook.com', '111111')

------------------------------------------------------------------------------------------------------------------

"""
ABSTRAÇÃO E ENCAPSULAMENTO

- Não é pré-requisito para resolver qualquer problema
- O diferencial está na forma de como resolvemos os mais diversos problemas
- Deve-se pensar sobre qual estilo de programação usar para resolver determinado problema
- O grande objetivo da POO é encapsular o código dentro de um grupo lógico e hierárquico de classes

Encapsular / cápsula:

             Classe
------------------------------------
|       Atributos e métodos        |
-----------------------------------

- É o agrupamento de atributos e métodos (públicos e privados), fazendo com a abstração seja possível

Relembre, atributos e métodos privados

Imagine que temos uma classe chamdda Pessoa, contendo um atributo privado chamado __nome e um método privado chamado
__falar().

Esses elementos privados só devem/deveriam ser acessados dentro da classe. Mas o Python não bloqueia esse acesso fora
da classe. Pois o Python possui um fenômeno chamdo Name Mangling, que faz uma alteração na forma de acessar os elementos
privados, veja:

_Classe__elemento

Exemplo: acessando elementos privados fora da classe (não recomendado, haja visto que sempre há um motivo para definir
um atributo com sendo privado).

instancia._Pessoa__nome
instancia._Pessoa__falar()


---------------

ABSTRAÇÃO EM POO: ato de expor apenas dados relevantes de uma classe, no qual escondemos atributos e métodos privados
que o usuário não precisa ter conhecimento a priori. Lembrar do exemplo da máquina de café;
 - não precisamos como a máquina funciona internamente. Queremos apenas o dado relevante, o café pronto e botões
 para escolher qual o tipo de café queremos. Ou seja, dados irrelevantes são removidas, abstraídas.
"""

# exemplo:


class Conta:

    contador = 400  # atributo de classe

    def __init__(self, titular, saldo, limite):  # atributos de classe
        self.numero = Conta.contador
        self.titular = titular
        self.saldo = saldo
        self.limite = limite
        Conta.contador += 1

    def extrato(self):  # métodos de instância
        print(f'Saldo de {self.saldo} do titular {self.titular} com limite de {self.limite}')

    def depositar(self, valor):
        self.saldo += valor

    def sacar(self, valor):
        self.saldo -= valor


# testando

conta1 = Conta('Francisco', 150.00, 1500)
print(conta1)  # imprimie o endereço de memória


# Problema: Atributos públicos (fazemos acesso direto). Com o acesso direto podemos alterar os dados
print(conta1.numero)
print(conta1.titular)
print(conta1.saldo)
print(conta1.limite)
print('-----')

# Imagine
conta1.numero = 42
conta1.titular = 'Outra pessoa'
conta1.saldo = 999999
conta1.limite = 8888888888

print(conta1.__dict__)  # os dados mudaram, isso não é legal, não tem segurança.
print('-----')
conta1.extrato()


# Para resolver este problema, devemos encapsular (manter seguro) os dados. Veja:

class ContaRefatorada:

    contador = 400  # atributo de classe

    def __init__(self, titular, saldo, limite):  # atributos de classe
        self.__numero = Conta.contador
        self.__titular = titular
        self.__saldo = saldo
        self.__limite = limite
        Conta.contador += 1

    def extrato(self):  # métodos de instância
        print(f'Saldo de {self.__saldo} do titular {self.__titular} com limite de {self.__limite}')

    def depositar(self, valor):
        self.__saldo += valor

    def sacar(self, valor):
        self.__saldo -= valor


conta2 = ContaRefatorada('Francisco', 150.00, 1500)

"""
As linhas de código abaixo não funcionam mais.

print(conta2.numero)
print(conta2.titular)
print(conta2.saldo)
print(conta2.limite)
print('-----')

conta2.numero = 42
conta2.titular = 'Outra pessoa'
conta2.saldo = 999999
conta2.limite = 8888888888
"""
print('-----')

print(conta2.__dict__)
print('-----')
conta2.extrato()
print('-----')

# Os atributos estão seguros (privados). Mas o Python ainda permite o acesso a estes dados
print(conta2._ContaRefatorada__titular)  # Name Mangling (não recomendado)

conta2._ContaRefatorada__titular = 'Outra pessoa'
print(conta2.__dict__)
conta2.depositar(150)
print(conta2.__dict__)


# Nota: Nesse caso, nossos métodos não precisam ser privados. Pois precisamos fazer acesso a eles fora da classe

------------------------------------------------------------------------------------------------------------------

"""
HERANÇA (INHERITANCE)

- Tema muito legal
- É a possibilidade de reaproveitar o código (ato de herdar atributos e métodos para uma nova classe)
- Extender as classes

Pense nas seguintes entidades:

    Cliente
        - nome;
        - sobrenome;
        - cpf;
        - renda;

    Funcionario
        - nome
        - sobrenome
        - cpf
        - matrícula;



Nota:
- Perceba que quando uma herança é criada, a IDE do PyCharm indica com os sinalizadores que está rolando uma herança
em algum lugar do código - os sinalizadores (azuis) do lado lado direito da número das linhas.

- Quando uma classe herda de outra classe, todos os atributos e métodos dessa classe sõa herdados.
- Quando uma classe herda de outra classe, a classe herdada (no nosso caso a classe PESSOA) é conhecida como:
    - super classe ----------------------------------------------------- foque nessa nomenclatura
    - classe mãe
    - classe pai
    - classe base
    - classe genérica

- Quando uma classe herda de outra classe (no nosso caso, a classe NovoCliente e NovoFuncionário), é conhecida por:
    - sub classe
    - classe filha
    - classe específica




Com o método super() podemos fazer acesso a qualquer atrbuto é método de uma Super Classe. Em nosso caso, estamos
fazendo acesso ao método construtor da super classe.
"""


class Cliente:
    def __init__(self, nome, sobrenome, cpf, renda):
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__cpf = cpf
        self.__renda = renda

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'


class Funcionario:

    def __init__(self, nome, sobrenome, cpf, matricula):
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__cpf = cpf
        self.__matricula = matricula

    def nome_completo(self):
        return f'{self.__nome} {self.__sobrenome}'


cliente1 = Cliente('Francisco', 'Araújo', '1111.1111.1111.11', 5000)
funcionario1 = Funcionario('Francisco', 'Araújo', '1111.1111.1111.11', 1212121212)
print(cliente1.__dict__)
print(funcionario1.__dict__)

"""
Veja a quantidade de atributos repetidos nas duas classes.
A pergunta que deve ser feita:Existe alguma entidade genérica o suficiente para encapsular os atributos e métodos comuns a outras entidades?
"""


# Vamos refatorar as classes anteriores criando uma nova classe.


class Pessoa:

    def __init__(self, nome, sobrenome, cpf):  # atributos privados
        self.__nome = nome
        self.__sobrenome = sobrenome
        self.__cpf = cpf

    def nome_completo(self):  # método público
        return f'{self.__nome} {self.__sobrenome}'


# Criando a herança
class NovoCliente(Pessoa):  # NovoCliente herda de Pessoa
    def __init__(self, nome, sobrenome, cpf, renda):
        super().__init__(nome, sobrenome, cpf)  # é precisso criar este método super().__init__
        # Pessoa.__init__(self, nome, sobrenome, cpf)  # Tabém poderia ser assim, mas não é a forma comum de acessar os
        # dados da super classe
        self.__renda = renda


class NovoFuncionario(Pessoa):  # NovoFuncionario herda de Pessoa
    def __init__(self, nome, sobrenome, cpf, matricula):
        super().__init__(nome, sobrenome, cpf)
        self.__matricula = matricula

    def nome_completo(self):
        print(super().nome_completo())  # super() acessa a super classe; nome_completo() acessa esse método contido lá.
        return f'Funcionário: {self.__matricula} Nome: {self._Pessoa__nome}'  # overriding


# Veja a quantidade de códigos que foi economizado
# Testando

print('------')
cliente2 = NovoCliente('Francisco', 'Araújo', '123.123.123-22', 10000)
funcionario2 = NovoFuncionario('Clarice', 'Savi', '111.111.111-11', '1213213212')

print(cliente2.nome_completo())  # veja que o método nome_completo() é da super classe
print(funcionario2.nome_completo())
print('-----')

print(cliente2.__dict__)  # conseguimos observar a qual classe cada atributo pertence
print(funcionario2.__dict__)

"""
Tratando de outro tema: Sobrescrita de Métodos (Overriding): veja o método reimplementado (nome_completo()) na classe 
NovoFuncionario. Observe também a bolinha com um vetor vermelho nesse método e passe o mouse sobre ele. Passe o mouse 
também sobre a bolinha do método nome_completo() na classe Pessoa.

    - ocorre quando reescrevemos/reimplementamos um método presente na super classe em classes filhas. Veja o exemplo
    abaixo:
"""

------------------------------------------------------------------------------------------------------------------

"""
PROPRIEDADES (PROPERTIES)

- sempre criamos nossos atributos de forma privada. Como consequência, as propriedades getters() e setters() de acordo
como tal.
"""


class Conta:

    contador = 0

    def __init__(self, titular, saldo, limite):
        self.__numero = Conta.contador + 1
        self.__titular = titular
        self.__saldo = saldo
        self.__limite = limite
        Conta.contador += 1

    def extrato(self):
        return f'Saldo de {self.__saldo} do cliente {self.__titular}'

    def depositar(self, valor):
        self.__saldo += valor

    def sacar(self, valor):
        self.__saldo -= valor

    def transferir(self, valor, destino):
        self.__saldo -= valor
        destino.__saldo += valor


conta1 = Conta('Francisco', 3000, 5000)
conta2 = Conta('Lara', 5000, 8000)

print(conta1.extrato())
print(conta2.extrato())
print('------')


# Como somar o saldo das duas contas?
"""
Não faça isso, não acesse um elemento privado se ele foi criado para ser privado:

soma = conta1._Conta__saldo + conta2._Conta__saldo
print(soma)
"""

"""
Crie métodos gettters() e setters() quando se deseja minupular os atributos privados de uma classe. Esses métodos 
públicos são criados quando temos atributos privados em nossas classes. Onde, getters retornam valor do atributo 
enquanto que os setters alteram o valor do mesmo.

Por definição, o nome do método deve ser:
    - get_atributo  (geralmente fazemos este, menos perigoso)
    - set_atributo  (geralmente não fazemos este, mais perigoso - pois pode alterar o valor de um atributo)
"""


class NovaConta:

    contador = 0

    def __init__(self, titular, saldo, limite):
        self.__numero = NovaConta.contador + 1
        self.__titular = titular
        self.__saldo = saldo
        self.__limite = limite
        NovaConta.contador += 1

    def extrato(self):
        return f'Saldo de {self.__saldo} do cliente {self.__titular}'

    def depositar(self, valor):
        self.__saldo += valor

    def sacar(self, valor):
        self.__saldo -= valor

    def transferir(self, valor, destino):
        self.__saldo -= valor
        destino.__saldo += valor

    def get_numero(self):
        return self.__numero

    def get_titular(self):
        return self.__titular

    def set_titular(self, titular):  # recebe o valor do atributo e faz alteração do mesmo
        self.__titular = titular

    def get_saldo(self):
        return self.__saldo

    def get_limite(self):
        return self.__limite

    def set_limite(self, limite):
        self.__limite = limite


conta3 = NovaConta('Francisco', 3000, 5000)
conta4 = NovaConta('Lara', 5000, 8000)
print(conta3.extrato())
print(conta4.extrato())
print(conta3.get_saldo() + conta4.get_saldo())
print('------')
print(conta3.__dict__)
print(conta3.set_limite(10_000))
print(conta3.__dict__)  # Veja que o valor do limite será alterado de 5000 para 10000
print('-----')

"""
Até aqui aplicamos muito bem os conceitos e vimos que os métodos getters() e setters() funcionam muito bem. Todavia,
essa nomenclatura não é muito amigável, por vezez, até se parece com a nomenclatura aplicada na linguagem java. Há outra
tipo de nomenclatura, usando propreidades (property):

- O @property faz o papel do método getter()
- E se você quiser criar um setter()?:
    @nomeDaPropriedade.setter no lugar de @property
"""


class OutraConta:

    contador = 0

    def __init__(self, titular, saldo, limite):
        self.__numero = OutraConta.contador + 1
        self.__titular = titular
        self.__saldo = saldo
        self.__limite = limite
        OutraConta.contador += 1

    @property  # Um decorador. Palavra chave para criar as propriedades. Geralmente logo abaixo de método construtor
    def numero(self):
        return self.__numero

    @property
    def titular(self):
        return self.__titular

    @property
    def saldo(self):
        return self.__saldo

    @property
    def limite(self):
        return self.__limite

    @limite.setter
    def limite(self, novo_limite):
        self.__limite = novo_limite

    def extrato(self):  # método de instância
        return f'Saldo de {self.__saldo} do cliente {self.__titular}'

    def depositar(self, valor):
        self.__saldo += valor

    def sacar(self, valor):
        self.__saldo -= valor

    def transferir(self, valor, destino):
        self.__saldo -= valor
        destino.__saldo += valor

    @property
    def valor_total(self):
        return self.__saldo + self.__limite


conta5 = OutraConta('Francisco', 3000, 5000)
conta6 = OutraConta('LarA', 5000, 8000)
print(conta5.extrato())
print(conta6.extrato())
print(conta5.saldo + conta6.saldo)

print('------')
print(conta5.__dict__)
conta5.limite = 767676  # não é mais um método, é uma propriedade chamada limite. Funciona como o método setter()
print(conta5.__dict__)
print(conta5.limite)
print('-----')


# Além disso, é possível criar métodos como propriedades
"""
@property
def valor_total(self):
    return self.__saldo + self.__limite  
"""

print(conta5.valor_total)  # veja que não é uma função, pois: conta5.valor_total é diferente de conta5.valor_total(),
# com os parênteses
print(conta6.valor_total)

------------------------------------------------------------------------------------------------------------------

"""
O MÉTODO SUPER()

- O método super() faz referência a uma super classe
- Podemos usar esse método a partir do momento que temos herança em nossas classes.
- Podemos fazer acesso a qualquer elemento da classe pai
"""


class Animal:

    def __init__(self, nome, especie):
        self.__nome = nome
        self.__especie = especie

    def faz_som(self, som):
        print(f'O {self.__nome} fala {som}')


class Gato(Animal):  # é a classe filha, ou seja, a classe específica

    def __init__(self, nome, especie, raca):
        # Animal.__init__(self, nome, especie)
        super().__init__(nome, especie)
        super().faz_som('som de gato tipo cachorro')
        self.__raca = raca


felix = Gato('Felix', 'felino', 'Angorá')
felix.faz_som('som de gato')

------------------------------------------------------------------------------------------------------------------

"""
HERANÇA MÚLTIPLA

    Enquando que no java conseguimos herdar diretamente apenas de uma classe, aqui no Python conseguimos herdar de múltiplas
classes.

Nota:
    A herança múltipla pode ser feita de duas maneiras:
        - Multiderivação Direta
        - Multiderivação Indireta

Class Cliente(Pessoa) -> A classe Cliente DERIVA (classe que herda de outra classe) de Pessoa. Ou seja, multiderivação é
a herança múltipla.


Obs.:
- Não importa se a derivação é direta ou indireta. A classe que realizar a herança herdará todos os atributos e
métodos das super classes.


class Pessoa:
    pass

é equivalente a

class Pessoa(object):
    pass




"""

# Exemplo 1 - Multiderivação Direta


class Base1:
    pass


class Base2:
    pass


class Base3:
    pass


class MultiDerivada(Base1, Base2, Base3):  # herda 3 classes
    pass


# Exemplo 2 - Multiderivação Indireta


class Base4:
    pass


class Base5(Base4):
    pass


class Base6(Base5):  # herda diretamente a Base5 e indiretamente a Base4
    pass


class MultiDerivadaBases(Base6):  # herda diretamente a Base6 e indiretamente a Base5 e Base4
    pass


class Animal:
    def __init__(self, nome):
        self.__nome = nome

    def cumprimentar(self):
        return f'Eu sou {self.__nome}'


class Aquatico(Animal):

    def __init__(self, nome):
        super().__init__(nome)

    def nadar(self):
        return f'{self._Animal__nome} está nadando.'

    def cumprimentar(self):  # sobrescrevendo o método cumprimentar()
        return f'Eu sou {self._Animal__nome} do mar!'


class Terrestre(Animal):

    def __init__(self, nome):
        super().__init__(nome)

    def andar(self):
        return f'{self._Animal__nome} está andando.'

    def cumprimentar(self):
        return f'Eu sou {self._Animal__nome} da terra!'


class Pinguim(Terrestre, Aquatico):  # herança múltipla. Herdando diretamente Terrestre e Aquatico e indiretamente de
    # Animal. Pinguim anda, nada e cumprimenta. A pergunta que fica é: Quando o pinguim tiver que cumprimentar, qual dos
    # três métodos ele irá executar?

    def __init__(self, nome):
        super().__init__(nome)


# Testando

baleia = Aquatico('Sara')
print(baleia.nadar())
print(baleia.cumprimentar())
print('-----')


tatu = Terrestre('Gaspar')
print(tatu.andar())
print(tatu.cumprimentar())
print('-----')

son = Pinguim('Son')
print(son.andar())
print(son.nadar())
print(son.cumprimentar())  # qual dos metodos cumprimentar() será executado? A escolha é feita por:
# Method Resolution Order - MRO.
print('------')

"""
Vai executar o método cumprimentar() da classe Terrestre, pois é o primeiro da ordem de herança: Eu sou Son da terra!. 
Se o primeiro da ordem de herança fosse Aquatico, o método cumprimentar() seria: Eu sou Son do mar!

"""


# Descobrindo de qual instância é determinado objeto:

print(f'son é instância de Pinguim? {isinstance(son, Pinguim)}')  # retorna um booleano

------------------------------------------------------------------------------------------------------------------

"""
Aula 88

MRO - METHOD RESOLUTION ORDER

- É a ordem de execução, ou seja, os métodos são executados na ordem
- Fenômeno que ocoore quando temos herança mútlipla.
- Nesse caso, o super() funciona para a classe que tem apenas uma herança, no caso a classe Aquatico

Podemos conferir a ordem de execução dos métodos de três formas:
    - via propriedade da classe __mro__
    - via método mro()
    - via help

"""


class Animal:
    def __init__(self, nome):
        self.__nome = nome

    def cumprimentar(self):
        return f'Eu sou {self.__nome}'


class Aquatico(Animal):

    def __init__(self, nome):
        super().__init__(nome)

    def nadar(self):
        return f'{self._Animal__nome} está nadando.'

    def cumprimentar(self):  # sobrescrevendo o método cumprimentar()
        return f'Eu sou {self._Animal__nome} do mar!'


class Terrestre(Animal):

    def __init__(self, nome):
        super().__init__(nome)

    def andar(self):
        return f'{self._Animal__nome} está andando.'

    def cumprimentar(self):
        return f'Eu sou {self._Animal__nome} da terra!'


class Pinguim(Aquatico, Terrestre):
    def __init__(self, nome):
        super().__init__(nome)

    def cumprimentar(self):
        return 'Comprimentar Pinguim'


# caso 1: class Pinguim(Terrestre, Aquatico):

shef = Pinguim('shef')
print(shef.cumprimentar())
"""
Eu sou shef da terra!
"""

# caso 2: class Pinguim(Aquatico, Terrestre):
"""
Eu sou shef do mar!
"""

# no terminal faça:
"""
from MRO import Pinguim

------------via propriedadde------------

Pinguim.__mro__

Ou seja, a ordem de execução seria:

1°: <class 'MRO.Pinguim'>
2°: <class 'MRO.Aquatico'>
3°: <class 'MRO.Terrestre'>
4°: <class 'MRO.Animal'>
5°: <class 'object'>


------------via método------------
Pinguim.mro()

------------via help------------EU GOSTEI MAIS DESSE
help(Piguim)
"""
------------------------------------------------------------------------------------------------------------------

